<?xml version='1.0' encoding='UTF-8'?>
<xwikidoc version="1.1">
  <web>RISCOSSPlatformCode</web>
  <name>GithubLogin</name>
  <language/>
  <defaultLanguage>en</defaultLanguage>
  <translation>0</translation>
  <creator>XWiki.Admin</creator>
  <creationDate>1430839817000</creationDate>
  <author>xwiki:XWiki.superadmin</author>
  <contentAuthor>xwiki:XWiki.superadmin</contentAuthor>
  <date>1443608128000</date>
  <contentUpdateDate>1443449820000</contentUpdateDate>
  <version>6.31</version>
  <title/>
  <comment>Upload new image github.png</comment>
  <minorEdit>true</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>{{velocity}}&#xd;
&#xd;
#if("$!request.getParameter('xpage')" != "" &amp;&amp; $request.getParameter('xpage').equals("plain") &amp;&amp; "$!request.getParameter('outputSyntax')" != "" &amp;&amp; $request.getParameter('outputSyntax').equals("plain"))&#xd;
&#xd;
#set($rep = $xwiki.createUser(true))&#xd;
#set($loginURL = "")&#xd;
#if($rep >= 0 || $rep == -3) ## User created with success or the user already exists&#xd;
#set($rep = 1)&#xd;
## Get the login URL for the connected user&#xd;
#set($username = $request.getParameter("xwikiname"))&#xd;
#set($userDoc = $xwiki.getDocument("XWiki.${username}"))&#xd;
#set($userObj = $userDoc.getObject("XWiki.XWikiUsers"))&#xd;
#set($password = $request.getParameter("register_password"))&#xd;
#set($discard = $userObj.set("password",$password))&#xd;
#set($discard = $userDoc.saveAsAuthor())&#xd;
#if (!$xwiki.getUser($userDoc.getFullName()).isUserInGroup("RISCOSSPlatformCode.ProducersGroup"))&#xd;
    #set($group = $xwiki.getDocument('RISCOSSPlatformCode.ProducersGroup'))&#xd;
    #set($gObj = $group.newObject('XWiki.XWikiGroups'))&#xd;
    #set($discard = $gObj.set('member', $userDoc.getFullName()))&#xd;
    $group.saveAsAuthor("Added user")&#xd;
#end&#xd;
#set($loginURL = $xwiki.getURL("XWiki.XWikiLogin","loginsubmit","j_username=${username}&amp;j_password=${password}&amp;form_token=${services.csrf.getToken()}"))&#xd;
#set($data = {"j_username" : "$username", "j_password" : "$password", "form_token" : "${services.csrf.getToken()}"})&#xd;
#else ## Error&#xd;
##ToDo&#xd;
#set($rep = -1)&#xd;
#end&#xd;
&#xd;
{"rep" : "$!rep","loginURL" : "$!loginURL","data" : "$data"}&#xd;
&#xd;
#end&#xd;
&#xd;
{{/velocity}}&#xd;
</content>
  <attachment>
    <filename>github.png</filename>
    <author>xwiki:XWiki.superadmin</author>
    <date>1441211779000</date>
    <version>1.4</version>
    <comment/>
    <content>iVBORw0KGgoAAAANSUhEUgAAABgAAAAXCAYAAAARIY8tAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffCQIQJA0b2pDLAAAE7klEQVRIx51Vf0yUdRj/fN/3vfe4g+O9H3CeXgg3WUpOEFNqmqEO/BHl2iLE1ZwTczRB2ppjSrNa+ges1tqaa5TOMiPUOXci2blohCOtDSWmiJhpcr88DuIAuffufd+nP1KmKIp9tu8f3+15Ps/zeb7P83yBCdi7dy8AgIgSMAUQkY6IUFtbiynj1KlTz2ZlZTUXFhZ+SESmO0Q8EaUQkXTXrri4eHd6evrRurq6l/AkqKqqagJAgiCQ0+kM5+bmBgwGQ79OpxsQRXHA6XQG7XZ7SBRFAkAVFRWeybiEey+BQAAOhwM6nU4GAEVR4PV6rV6v9z6niXfGGA8Ara2tyM/PnzxAeXk5AKCnpyfxSRS3tbXlEJGJMTb8WOOGhoaVJpNpFAA9yamsrGwCgO7u7skVAEB9ff3SeDxuBADXjFQsyX4aCToekdsyRsZkiIIAKdEAvSig+7ofZy/2Iq6oaGlpWUhEImMs9sgAkUhEVVUV6dNT8NMXu+DKXQrII8CtawDjAGKAXgdMywKG/Ni++1N83PADotEoAJgAhO/l4yYGcLlcCoGhdNUSuLLn43T1HvzhbgMSTIAcA+IxxJkJJ8qqcONSEBtKi2Ay6iFJkgog8kAXeTweCxHNVxQlk4h4n8+X0XSyGVE5DhBB0OvvZEFQFA2CwAOaCiHRCGgKiAiKomD27NnSmTNnNrvdbvA8L3Mc1ytJUgdfXFzskWVZ0TQtk4gMFoulh3GceOz4iVkbCxZh7qtFSJ0ugQ0PoP+GH6LRAB2vIn3NKtjSkvHlgUbqDgyzt8vLP2KM6VVVtRPRzHg8nsJx3A52+fJlp9lsDjkcjvseZ3t19VH34UOv1axfiYJF85BqsWAkGIbRkgwmCrjpC+BrTzu+b+9B5bZtNRVbt9YyxtS7/uFwmA+FQo5xwr6+PnR0dhmrdu5o37Rt60EAOH7yx4Llq4oO5i9bPmTUi2S3mclmTqIZDgcVrl5z9o1NW/Zf/fNa3sQBnDiI4/j970DCiV/a1z//4gv0+uaNHiLiiMia4XIpAEivTxjv+501NZ/d6xsMBqc+mec7OtbyOoHsGWkk2VNIL4rkcrloxYoVZDabyel0UklJiW8qXA+06eHGRuQuWOD+7uC3JXOeSj+5eMHC07wgwCxJYIwBINis1of6PnbZAUDJunXYt28f1pWWHgFwhIhsSUlJ/aqigOd5gDEoqgo9x0X/lwIAKCsrQ33fcGJzlJbVtP72TRTAgNUO78w5kIUEDNmduCCr6QeitOvYzfDixqv+8c9p0D9h0963rm+F4LCnYs+N26v9TPf5P4yf9evuOkzLnAZfazPy3nsfl/Z/BcFkweDNUXrmrQ3MkT0X5rGxs3kR35b12ZldE5NlD1PwTu+QO5CU/EqSRhiLEIJXOHAIY/o8Gwb7YhgJjiF5hoQUlwpN4zGsA5Zc6fikKk34gGXkjExaosCtEADg3aGL1Rn9/iaFNJkzEFRNA2e0YtAHjA6I0EnJYKIGjRGgyLGcnguHsvv/amYZOSNXujofraD1fCfyc3NA505bPaNsTldi2pvXg0abKgqJnMjE2DAg6pWYJMoxpyEymOnt3Z9pTvTPKii61uR24+W1ax9fou7OC8jKmf/fiutu4SEP8r39xA/FGWMcwcTFycbxmi0pVUPesjhjDOdaf8Zz+csf4PoX4BkllD1DqWMAAAAASUVORK5CYII=</content>
    <filesize>4028</filesize>
  </attachment>
  <object>
    <name>RISCOSSPlatformCode.GithubLogin</name>
    <number>1</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>df99bdad-5054-4b69-b74f-2293842d654e</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <disabled>0</disabled>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage=Always on this page|onDemand=On demand|always=Always on this wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>require(['jquery'],function($){&#xd;
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){&#xd;
module.exports = {&#xd;
  oauthd_url: "https://oauth.io",&#xd;
  oauthd_api: "https://oauth.io/api",&#xd;
  version: "web-0.4.0",&#xd;
  options: {}&#xd;
};&#xd;
&#xd;
},{}],2:[function(require,module,exports){&#xd;
"use strict";&#xd;
module.exports = function(Materia) {&#xd;
  var $;&#xd;
  $ = Materia.getJquery();&#xd;
  return {&#xd;
    get: (function(_this) {&#xd;
      return function(url, params) {&#xd;
        var base;&#xd;
        base = Materia.getOAuthdURL();&#xd;
        return $.ajax({&#xd;
          url: base + url,&#xd;
          type: 'get',&#xd;
          data: params&#xd;
        });&#xd;
      };&#xd;
    })(this),&#xd;
    post: (function(_this) {&#xd;
      return function(url, params) {&#xd;
        var base;&#xd;
        base = Materia.getOAuthdURL();&#xd;
        return $.ajax({&#xd;
          url: base + url,&#xd;
          type: 'post',&#xd;
          data: params&#xd;
        });&#xd;
      };&#xd;
    })(this),&#xd;
    put: (function(_this) {&#xd;
      return function(url, params) {&#xd;
        var base;&#xd;
        base = Materia.getOAuthdURL();&#xd;
        return $.ajax({&#xd;
          url: base + url,&#xd;
          type: 'put',&#xd;
          data: params&#xd;
        });&#xd;
      };&#xd;
    })(this),&#xd;
    del: (function(_this) {&#xd;
      return function(url, params) {&#xd;
        var base;&#xd;
        base = Materia.getOAuthdURL();&#xd;
        return $.ajax({&#xd;
          url: base + url,&#xd;
          type: 'delete',&#xd;
          data: params&#xd;
        });&#xd;
      };&#xd;
    })(this)&#xd;
  };&#xd;
};&#xd;
&#xd;
},{}],3:[function(require,module,exports){&#xd;
"use strict";&#xd;
var Location, Url, cache, config, cookies;&#xd;
&#xd;
config = require('../config');&#xd;
&#xd;
Url = require("../tools/url");&#xd;
&#xd;
Location = require('../tools/location_operations');&#xd;
&#xd;
cookies = require("../tools/cookies");&#xd;
&#xd;
cache = require("../tools/cache");&#xd;
&#xd;
module.exports = function(window, document, jquery, navigator) {&#xd;
  var Materia, location_operations;&#xd;
  Url = Url(document);&#xd;
  cookies.init(config, document);&#xd;
  location_operations = Location(document);&#xd;
  cache.init(cookies, config);&#xd;
  Materia = {&#xd;
    initialize: function(public_key, options) {&#xd;
      var i;&#xd;
      config.key = public_key;&#xd;
      if (options) {&#xd;
        for (i in options) {&#xd;
          config.options[i] = options[i];&#xd;
        }&#xd;
      }&#xd;
    },&#xd;
    setOAuthdURL: function(url) {&#xd;
      config.oauthd_url = url;&#xd;
      config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^/]+/)[0];&#xd;
    },&#xd;
    getOAuthdURL: function() {&#xd;
      return config.oauthd_url;&#xd;
    },&#xd;
    getVersion: function() {&#xd;
      return config.version;&#xd;
    },&#xd;
    extend: function(name, module) {&#xd;
      return this[name] = module(this);&#xd;
    },&#xd;
    getConfig: function() {&#xd;
      return config;&#xd;
    },&#xd;
    getWindow: function() {&#xd;
      return window;&#xd;
    },&#xd;
    getDocument: function() {&#xd;
      return document;&#xd;
    },&#xd;
    getNavigator: function() {&#xd;
      return navigator;&#xd;
    },&#xd;
    getJquery: function() {&#xd;
      return jquery;&#xd;
    },&#xd;
    getUrl: function() {&#xd;
      return Url;&#xd;
    },&#xd;
    getCache: function() {&#xd;
      return cache;&#xd;
    },&#xd;
    getCookies: function() {&#xd;
      return cookies;&#xd;
    },&#xd;
    getLocationOperations: function() {&#xd;
      return location_operations;&#xd;
    }&#xd;
  };&#xd;
  return Materia;&#xd;
};&#xd;
&#xd;
},{"../config":1,"../tools/cache":9,"../tools/cookies":10,"../tools/location_operations":12,"../tools/url":14}],4:[function(require,module,exports){&#xd;
"use strict";&#xd;
var cookies, oauthio_requests, sha1;&#xd;
&#xd;
cookies = require("../tools/cookies");&#xd;
&#xd;
oauthio_requests = require("./request");&#xd;
&#xd;
sha1 = require("../tools/sha1");&#xd;
&#xd;
module.exports = function(Materia) {&#xd;
  var $, Url, cache, client_states, config, document, location_operations, oauth, oauth_result, oauthio, parse_urlfragment, providers_api, window;&#xd;
  Url = Materia.getUrl();&#xd;
  config = Materia.getConfig();&#xd;
  document = Materia.getDocument();&#xd;
  window = Materia.getWindow();&#xd;
  $ = Materia.getJquery();&#xd;
  cache = Materia.getCache();&#xd;
  providers_api = require('./providers')(Materia);&#xd;
  config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^/]+/)[0];&#xd;
  client_states = [];&#xd;
  oauth_result = void 0;&#xd;
  (parse_urlfragment = function() {&#xd;
    var cookie_state, results;&#xd;
    results = /[\\#&amp;]oauthio=([^&amp;]*)/.exec(document.location.hash);&#xd;
    if (results) {&#xd;
      document.location.hash = document.location.hash.replace(/&amp;?oauthio=[^&amp;]*/, "");&#xd;
      oauth_result = decodeURIComponent(results[1].replace(/\+/g, " "));&#xd;
      cookie_state = cookies.readCookie("oauthio_state");&#xd;
      if (cookie_state) {&#xd;
        client_states.push(cookie_state);&#xd;
        cookies.eraseCookie("oauthio_state");&#xd;
      }&#xd;
    }&#xd;
  })();&#xd;
  location_operations = Materia.getLocationOperations();&#xd;
  oauthio = {&#xd;
    request: oauthio_requests(Materia, client_states, providers_api)&#xd;
  };&#xd;
  oauth = {&#xd;
    initialize: function(public_key, options) {&#xd;
      return Materia.initialize(public_key, options);&#xd;
    },&#xd;
    setOAuthdURL: function(url) {&#xd;
      config.oauthd_url = url;&#xd;
      config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^/]+/)[0];&#xd;
    },&#xd;
    create: function(provider, tokens, request) {&#xd;
      var i, make_res, make_res_endpoint, res;&#xd;
      if (!tokens) {&#xd;
        return cache.tryCache(oauth, provider, true);&#xd;
      }&#xd;
      if (typeof request !== "object") {&#xd;
        providers_api.fetchDescription(provider);&#xd;
      }&#xd;
      make_res = function(method) {&#xd;
        return oauthio.request.mkHttp(provider, tokens, request, method);&#xd;
      };&#xd;
      make_res_endpoint = function(method, url) {&#xd;
        return oauthio.request.mkHttpEndpoint(provider, tokens, request, method, url);&#xd;
      };&#xd;
      res = {};&#xd;
      for (i in tokens) {&#xd;
        res[i] = tokens[i];&#xd;
      }&#xd;
      res.get = make_res("GET");&#xd;
      res.post = make_res("POST");&#xd;
      res.put = make_res("PUT");&#xd;
      res.patch = make_res("PATCH");&#xd;
      res.del = make_res("DELETE");&#xd;
      res.me = oauthio.request.mkHttpMe(provider, tokens, request, "GET");&#xd;
      return res;&#xd;
    },&#xd;
    popup: function(provider, opts, callback) {&#xd;
      var defer, frm, getMessage, gotmessage, interval, res, url, wnd, wndTimeout, wnd_options, wnd_settings;&#xd;
      gotmessage = false;&#xd;
      getMessage = function(e) {&#xd;
        if (!gotmessage) {&#xd;
          if (e.origin !== config.oauthd_base) {&#xd;
            return;&#xd;
          }&#xd;
          try {&#xd;
            wnd.close();&#xd;
          } catch (_error) {}&#xd;
          opts.data = e.data;&#xd;
          oauthio.request.sendCallback(opts, defer);&#xd;
          return gotmessage = true;&#xd;
        }&#xd;
      };&#xd;
      wnd = void 0;&#xd;
      frm = void 0;&#xd;
      wndTimeout = void 0;&#xd;
      defer = $.Deferred();&#xd;
      opts = opts || {};&#xd;
      if (!config.key) {&#xd;
        if (defer != null) {&#xd;
          defer.reject(new Error("OAuth object must be initialized"));&#xd;
        }&#xd;
        if (callback == null) {&#xd;
          return defer.promise();&#xd;
        } else {&#xd;
          return callback(new Error("OAuth object must be initialized"));&#xd;
        }&#xd;
      }&#xd;
      if (arguments.length === 2 &amp;&amp; typeof opts === 'function') {&#xd;
        callback = opts;&#xd;
        opts = {};&#xd;
      }&#xd;
      if (cache.cacheEnabled(opts.cache)) {&#xd;
        res = cache.tryCache(oauth, provider, opts.cache);&#xd;
        if (res) {&#xd;
          if (defer != null) {&#xd;
            defer.resolve(res);&#xd;
          }&#xd;
          if (callback) {&#xd;
            return callback(null, res);&#xd;
          } else {&#xd;
            return defer.promise();&#xd;
          }&#xd;
        }&#xd;
      }&#xd;
      if (!opts.state) {&#xd;
        opts.state = sha1.create_hash();&#xd;
        opts.state_type = "client";&#xd;
      }&#xd;
      client_states.push(opts.state);&#xd;
      url = config.oauthd_url + "/auth/" + provider + "?k=" + config.key;&#xd;
      url += "&amp;d=" + encodeURIComponent(Url.getAbsUrl("/"));&#xd;
      if (opts) {&#xd;
        url += "&amp;opts=" + encodeURIComponent(JSON.stringify(opts));&#xd;
      }&#xd;
      if (opts.wnd_settings) {&#xd;
        wnd_settings = opts.wnd_settings;&#xd;
        delete opts.wnd_settings;&#xd;
      } else {&#xd;
        wnd_settings = {&#xd;
          width: Math.floor(window.outerWidth * 0.8),&#xd;
          height: Math.floor(window.outerHeight * 0.5)&#xd;
        };&#xd;
      }&#xd;
      if (wnd_settings.height == null) {&#xd;
        wnd_settings.height = (wnd_settings.height &lt; 350 ? 350 : void 0);&#xd;
      }&#xd;
      if (wnd_settings.width == null) {&#xd;
        wnd_settings.width = (wnd_settings.width &lt; 800 ? 800 : void 0);&#xd;
      }&#xd;
      if (wnd_settings.left == null) {&#xd;
        wnd_settings.left = window.screenX + (window.outerWidth - wnd_settings.width) / 2;&#xd;
      }&#xd;
      if (wnd_settings.top == null) {&#xd;
        wnd_settings.top = window.screenY + (window.outerHeight - wnd_settings.height) / 8;&#xd;
      }&#xd;
      wnd_options = "width=" + wnd_settings.width + ",height=" + wnd_settings.height;&#xd;
      wnd_options += ",toolbar=0,scrollbars=1,status=1,resizable=1,location=1,menuBar=0";&#xd;
      wnd_options += ",left=" + wnd_settings.left + ",top=" + wnd_settings.top;&#xd;
      opts = {&#xd;
        provider: provider,&#xd;
        cache: opts.cache&#xd;
      };&#xd;
      opts.callback = function(e, r) {&#xd;
        if (window.removeEventListener) {&#xd;
          window.removeEventListener("message", getMessage, false);&#xd;
        } else if (window.detachEvent) {&#xd;
          window.detachEvent("onmessage", getMessage);&#xd;
        } else {&#xd;
          if (document.detachEvent) {&#xd;
            document.detachEvent("onmessage", getMessage);&#xd;
          }&#xd;
        }&#xd;
        opts.callback = function() {};&#xd;
        if (wndTimeout) {&#xd;
          clearTimeout(wndTimeout);&#xd;
          wndTimeout = undefined;&#xd;
        }&#xd;
        if (callback) {&#xd;
          return callback(e, r);&#xd;
        } else {&#xd;
          return undefined;&#xd;
        }&#xd;
      };&#xd;
      if (window.attachEvent) {&#xd;
        window.attachEvent("onmessage", getMessage);&#xd;
      } else if (document.attachEvent) {&#xd;
        document.attachEvent("onmessage", getMessage);&#xd;
      } else {&#xd;
        if (window.addEventListener) {&#xd;
          window.addEventListener("message", getMessage, false);&#xd;
        }&#xd;
      }&#xd;
      if (typeof chrome !== "undefined" &amp;&amp; chrome.runtime &amp;&amp; chrome.runtime.onMessageExternal) {&#xd;
        chrome.runtime.onMessageExternal.addListener(function(request, sender, sendResponse) {&#xd;
          request.origin = sender.url.match(/^.{2,5}:\/\/[^/]+/)[0];&#xd;
          if (defer != null) {&#xd;
            defer.resolve();&#xd;
          }&#xd;
          return getMessage(request);&#xd;
        });&#xd;
      }&#xd;
      if (!frm &amp;&amp; (navigator.userAgent.indexOf("MSIE") !== -1 || navigator.appVersion.indexOf("Trident/") > 0)) {&#xd;
        frm = document.createElement("iframe");&#xd;
        frm.src = config.oauthd_url + "/auth/iframe?d=" + encodeURIComponent(Url.getAbsUrl("/"));&#xd;
        frm.width = 0;&#xd;
        frm.height = 0;&#xd;
        frm.frameBorder = 0;&#xd;
        frm.style.visibility = "hidden";&#xd;
        document.body.appendChild(frm);&#xd;
      }&#xd;
      wndTimeout = setTimeout(function() {&#xd;
        if (defer != null) {&#xd;
          defer.reject(new Error("Authorization timed out"));&#xd;
        }&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          opts.callback(new Error("Authorization timed out"));&#xd;
        }&#xd;
        try {&#xd;
          wnd.close();&#xd;
        } catch (_error) {}&#xd;
      }, 1200 * 1000);&#xd;
      wnd = window.open(url, "Authorization", wnd_options);&#xd;
      if (wnd) {&#xd;
        wnd.focus();&#xd;
        interval = window.setInterval(function() {&#xd;
          if (wnd === null || wnd.closed) {&#xd;
            window.clearInterval(interval);&#xd;
            if (!gotmessage) {&#xd;
              if (defer != null) {&#xd;
                defer.reject(new Error("The popup was closed"));&#xd;
              }&#xd;
              if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
                return opts.callback(new Error("The popup was closed"));&#xd;
              }&#xd;
            }&#xd;
          }&#xd;
        }, 500);&#xd;
      } else {&#xd;
        if (defer != null) {&#xd;
          defer.reject(new Error("Could not open a popup"));&#xd;
        }&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          opts.callback(new Error("Could not open a popup"));&#xd;
        }&#xd;
      }&#xd;
      return defer != null ? defer.promise() : void 0;&#xd;
    },&#xd;
    redirect: function(provider, opts, url) {&#xd;
      var redirect_uri, res;&#xd;
      if (arguments.length === 2) {&#xd;
        url = opts;&#xd;
        opts = {};&#xd;
      }&#xd;
      if (cache.cacheEnabled(opts.cache)) {&#xd;
        res = cache.tryCache(oauth, provider, opts.cache);&#xd;
        if (res) {&#xd;
          url = Url.getAbsUrl(url) + (url.indexOf("#") === -1 ? "#" : "&amp;") + "oauthio=cache";&#xd;
          location_operations.changeHref(url);&#xd;
          location_operations.reload();&#xd;
          return;&#xd;
        }&#xd;
      }&#xd;
      if (!opts.state) {&#xd;
        opts.state = sha1.create_hash();&#xd;
        opts.state_type = "client";&#xd;
      }&#xd;
      cookies.createCookie("oauthio_state", opts.state);&#xd;
      redirect_uri = encodeURIComponent(Url.getAbsUrl(url));&#xd;
      url = config.oauthd_url + "/auth/" + provider + "?k=" + config.key;&#xd;
      url += "&amp;redirect_uri=" + redirect_uri;&#xd;
      if (opts) {&#xd;
        url += "&amp;opts=" + encodeURIComponent(JSON.stringify(opts));&#xd;
      }&#xd;
      location_operations.changeHref(url);&#xd;
    },&#xd;
    callback: function(provider, opts, callback) {&#xd;
      var defer, res;&#xd;
      defer = $.Deferred();&#xd;
      if (arguments.length === 1 &amp;&amp; typeof provider === "function") {&#xd;
        callback = provider;&#xd;
        provider = undefined;&#xd;
        opts = {};&#xd;
      }&#xd;
      if (arguments.length === 1 &amp;&amp; typeof provider === "string") {&#xd;
        opts = {};&#xd;
      }&#xd;
      if (arguments.length === 2 &amp;&amp; typeof opts === "function") {&#xd;
        callback = opts;&#xd;
        opts = {};&#xd;
      }&#xd;
      if (cache.cacheEnabled(opts.cache) || oauth_result === "cache") {&#xd;
        res = cache.tryCache(oauth, provider, opts.cache);&#xd;
        if (oauth_result === "cache" &amp;&amp; (typeof provider !== "string" || !provider)) {&#xd;
          if (defer != null) {&#xd;
            defer.reject(new Error("You must set a provider when using the cache"));&#xd;
          }&#xd;
          if (callback) {&#xd;
            return callback(new Error("You must set a provider when using the cache"));&#xd;
          } else {&#xd;
            return defer != null ? defer.promise() : void 0;&#xd;
          }&#xd;
        }&#xd;
        if (res) {&#xd;
          if (callback) {&#xd;
            if (res) {&#xd;
              return callback(null, res);&#xd;
            }&#xd;
          } else {&#xd;
            if (defer != null) {&#xd;
              defer.resolve(res);&#xd;
            }&#xd;
            return defer != null ? defer.promise() : void 0;&#xd;
          }&#xd;
        }&#xd;
      }&#xd;
      if (!oauth_result) {&#xd;
        return;&#xd;
      }&#xd;
      oauthio.request.sendCallback({&#xd;
        data: oauth_result,&#xd;
        provider: provider,&#xd;
        cache: opts.cache,&#xd;
        callback: callback&#xd;
      }, defer);&#xd;
      return defer != null ? defer.promise() : void 0;&#xd;
    },&#xd;
    clearCache: function(provider) {&#xd;
      cookies.eraseCookie("oauthio_provider_" + provider);&#xd;
    },&#xd;
    http_me: function(opts) {&#xd;
      if (oauthio.request.http_me) {&#xd;
        oauthio.request.http_me(opts);&#xd;
      }&#xd;
    },&#xd;
    http: function(opts) {&#xd;
      if (oauthio.request.http) {&#xd;
        oauthio.request.http(opts);&#xd;
      }&#xd;
    },&#xd;
    getVersion: function() {&#xd;
      return Materia.getVersion.apply(this);&#xd;
    }&#xd;
  };&#xd;
  return oauth;&#xd;
};&#xd;
&#xd;
},{"../tools/cookies":10,"../tools/sha1":13,"./providers":5,"./request":6}],5:[function(require,module,exports){&#xd;
"use strict";&#xd;
var config;&#xd;
&#xd;
config = require("../config");&#xd;
&#xd;
module.exports = function(Materia) {&#xd;
  var $, providers_api, providers_cb, providers_desc;&#xd;
  $ = Materia.getJquery();&#xd;
  providers_desc = {};&#xd;
  providers_cb = {};&#xd;
  providers_api = {&#xd;
    execProvidersCb: function(provider, e, r) {&#xd;
      var cbs, i;&#xd;
      if (providers_cb[provider]) {&#xd;
        cbs = providers_cb[provider];&#xd;
        delete providers_cb[provider];&#xd;
        for (i in cbs) {&#xd;
          cbs[i](e, r);&#xd;
        }&#xd;
      }&#xd;
    },&#xd;
    fetchDescription: function(provider) {&#xd;
      if (providers_desc[provider]) {&#xd;
        return;&#xd;
      }&#xd;
      providers_desc[provider] = true;&#xd;
      $.ajax({&#xd;
        url: config.oauthd_api + "/providers/" + provider,&#xd;
        data: {&#xd;
          extend: true&#xd;
        },&#xd;
        dataType: "json"&#xd;
      }).done(function(data) {&#xd;
        providers_desc[provider] = data.data;&#xd;
        providers_api.execProvidersCb(provider, null, data.data);&#xd;
      }).always(function() {&#xd;
        if (typeof providers_desc[provider] !== "object") {&#xd;
          delete providers_desc[provider];&#xd;
          providers_api.execProvidersCb(provider, new Error("Unable to fetch request description"));&#xd;
        }&#xd;
      });&#xd;
    },&#xd;
    getDescription: function(provider, opts, callback) {&#xd;
      opts = opts || {};&#xd;
      if (typeof providers_desc[provider] === "object") {&#xd;
        return callback(null, providers_desc[provider]);&#xd;
      }&#xd;
      if (!providers_desc[provider]) {&#xd;
        providers_api.fetchDescription(provider);&#xd;
      }&#xd;
      if (!opts.wait) {&#xd;
        return callback(null, {});&#xd;
      }&#xd;
      providers_cb[provider] = providers_cb[provider] || [];&#xd;
      providers_cb[provider].push(callback);&#xd;
    }&#xd;
  };&#xd;
  return providers_api;&#xd;
};&#xd;
&#xd;
},{"../config":1}],6:[function(require,module,exports){&#xd;
"use strict";&#xd;
var Q, Url,&#xd;
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };&#xd;
&#xd;
Url = require('../tools/url')();&#xd;
&#xd;
Q = require('q');&#xd;
&#xd;
module.exports = function(Materia, client_states, providers_api) {&#xd;
  var $, cache, config, extended_methods, fetched_methods;&#xd;
  $ = Materia.getJquery();&#xd;
  config = Materia.getConfig();&#xd;
  cache = Materia.getCache();&#xd;
  extended_methods = [];&#xd;
  fetched_methods = false;&#xd;
  return {&#xd;
    retrieveMethods: function() {&#xd;
      var defer;&#xd;
      defer = Q.defer();&#xd;
      if (!fetched_methods) {&#xd;
        $.ajax(config.oauthd_url + '/api/extended-endpoints').then(function(data) {&#xd;
          extended_methods = data.data;&#xd;
          fetched_methods = true;&#xd;
          return defer.resolve();&#xd;
        }).fail(function(e) {&#xd;
          fetched_methods = true;&#xd;
          return defer.reject(e);&#xd;
        });&#xd;
      } else {&#xd;
        defer.resolve(extended_methods);&#xd;
      }&#xd;
      return defer.promise;&#xd;
    },&#xd;
    generateMethods: function(request_object, tokens, provider) {&#xd;
      var k, kk, name_array, pt, v, vv, _results;&#xd;
      if (extended_methods != null) {&#xd;
        _results = [];&#xd;
        for (k in extended_methods) {&#xd;
          v = extended_methods[k];&#xd;
          name_array = v.name.split('.');&#xd;
          pt = request_object;&#xd;
          _results.push((function() {&#xd;
            var _results1;&#xd;
            _results1 = [];&#xd;
            for (kk in name_array) {&#xd;
              vv = name_array[kk];&#xd;
              if (kk &lt; name_array.length - 1) {&#xd;
                if (pt[vv] == null) {&#xd;
                  pt[vv] = {};&#xd;
                }&#xd;
                _results1.push(pt = pt[vv]);&#xd;
              } else {&#xd;
                _results1.push(pt[vv] = this.mkHttpAll(provider, tokens, v, arguments));&#xd;
              }&#xd;
            }&#xd;
            return _results1;&#xd;
          }).apply(this, arguments));&#xd;
        }&#xd;
        return _results;&#xd;
      }&#xd;
    },&#xd;
    http: function(opts) {&#xd;
      var defer, desc_opts, doRequest, i, options;&#xd;
      doRequest = function() {&#xd;
        var i, k, qs, request;&#xd;
        request = options.oauthio.request || {};&#xd;
        if (!request.cors) {&#xd;
          options.url = encodeURIComponent(options.url);&#xd;
          if (options.url[0] !== "/") {&#xd;
            options.url = "/" + options.url;&#xd;
          }&#xd;
          options.url = config.oauthd_url + "/request/" + options.oauthio.provider + options.url;&#xd;
          options.headers = options.headers || {};&#xd;
          options.headers.oauthio = "k=" + config.key;&#xd;
          if (options.oauthio.tokens.oauth_token &amp;&amp; options.oauthio.tokens.oauth_token_secret) {&#xd;
            options.headers.oauthio += "&amp;oauthv=1";&#xd;
          }&#xd;
          for (k in options.oauthio.tokens) {&#xd;
            options.headers.oauthio += "&amp;" + encodeURIComponent(k) + "=" + encodeURIComponent(options.oauthio.tokens[k]);&#xd;
          }&#xd;
          delete options.oauthio;&#xd;
          return $.ajax(options);&#xd;
        }&#xd;
        if (options.oauthio.tokens) {&#xd;
          if (options.oauthio.tokens.access_token) {&#xd;
            options.oauthio.tokens.token = options.oauthio.tokens.access_token;&#xd;
          }&#xd;
          if (!options.url.match(/^[a-z]{2,16}:\/\//)) {&#xd;
            if (options.url[0] !== "/") {&#xd;
              options.url = "/" + options.url;&#xd;
            }&#xd;
            options.url = request.url + options.url;&#xd;
          }&#xd;
          options.url = Url.replaceParam(options.url, options.oauthio.tokens, request.parameters);&#xd;
          if (request.query) {&#xd;
            qs = [];&#xd;
            for (i in request.query) {&#xd;
              qs.push(encodeURIComponent(i) + "=" + encodeURIComponent(Url.replaceParam(request.query[i], options.oauthio.tokens, request.parameters)));&#xd;
            }&#xd;
            if (__indexOf.call(options.url, "?") >= 0) {&#xd;
              options.url += "&amp;" + qs;&#xd;
            } else {&#xd;
              options.url += "?" + qs;&#xd;
            }&#xd;
          }&#xd;
          if (request.headers) {&#xd;
            options.headers = options.headers || {};&#xd;
            for (i in request.headers) {&#xd;
              options.headers[i] = Url.replaceParam(request.headers[i], options.oauthio.tokens, request.parameters);&#xd;
            }&#xd;
          }&#xd;
          delete options.oauthio;&#xd;
          return $.ajax(options);&#xd;
        }&#xd;
      };&#xd;
      options = {};&#xd;
      i = void 0;&#xd;
      for (i in opts) {&#xd;
        options[i] = opts[i];&#xd;
      }&#xd;
      if (!options.oauthio.request || options.oauthio.request === true) {&#xd;
        desc_opts = {&#xd;
          wait: !!options.oauthio.request&#xd;
        };&#xd;
        defer = $.Deferred();&#xd;
        providers_api.getDescription(options.oauthio.provider, desc_opts, function(e, desc) {&#xd;
          if (e) {&#xd;
            return defer.reject(e);&#xd;
          }&#xd;
          if (options.oauthio.tokens.oauth_token &amp;&amp; options.oauthio.tokens.oauth_token_secret) {&#xd;
            options.oauthio.request = desc.oauth1 &amp;&amp; desc.oauth1.request;&#xd;
          } else {&#xd;
            options.oauthio.request = desc.oauth2 &amp;&amp; desc.oauth2.request;&#xd;
          }&#xd;
          defer.resolve();&#xd;
        });&#xd;
        return defer.then(doRequest);&#xd;
      } else {&#xd;
        return doRequest();&#xd;
      }&#xd;
    },&#xd;
    http_me: function(opts) {&#xd;
      var defer, desc_opts, doRequest, k, options;&#xd;
      doRequest = function() {&#xd;
        var defer, k, promise, request;&#xd;
        defer = $.Deferred();&#xd;
        request = options.oauthio.request || {};&#xd;
        options.url = config.oauthd_url + "/auth/" + options.oauthio.provider + "/me";&#xd;
        options.headers = options.headers || {};&#xd;
        options.headers.oauthio = "k=" + config.key;&#xd;
        if (options.oauthio.tokens.oauth_token &amp;&amp; options.oauthio.tokens.oauth_token_secret) {&#xd;
          options.headers.oauthio += "&amp;oauthv=1";&#xd;
        }&#xd;
        for (k in options.oauthio.tokens) {&#xd;
          options.headers.oauthio += "&amp;" + encodeURIComponent(k) + "=" + encodeURIComponent(options.oauthio.tokens[k]);&#xd;
        }&#xd;
        delete options.oauthio;&#xd;
        promise = $.ajax(options);&#xd;
        $.when(promise).done(function(data) {&#xd;
          defer.resolve(data.data);&#xd;
        }).fail(function(data) {&#xd;
          if (data.responseJSON) {&#xd;
            defer.reject(data.responseJSON.data);&#xd;
          } else {&#xd;
            defer.reject(new Error("An error occured while trying to access the resource"));&#xd;
          }&#xd;
        });&#xd;
        return defer.promise();&#xd;
      };&#xd;
      options = {};&#xd;
      for (k in opts) {&#xd;
        options[k] = opts[k];&#xd;
      }&#xd;
      if (!options.oauthio.request || options.oauthio.request === true) {&#xd;
        desc_opts = {&#xd;
          wait: !!options.oauthio.request&#xd;
        };&#xd;
        defer = $.Deferred();&#xd;
        providers_api.getDescription(options.oauthio.provider, desc_opts, function(e, desc) {&#xd;
          if (e) {&#xd;
            return defer.reject(e);&#xd;
          }&#xd;
          if (options.oauthio.tokens.oauth_token &amp;&amp; options.oauthio.tokens.oauth_token_secret) {&#xd;
            options.oauthio.request = desc.oauth1 &amp;&amp; desc.oauth1.request;&#xd;
          } else {&#xd;
            options.oauthio.request = desc.oauth2 &amp;&amp; desc.oauth2.request;&#xd;
          }&#xd;
          defer.resolve();&#xd;
        });&#xd;
        return defer.then(doRequest);&#xd;
      } else {&#xd;
        return doRequest();&#xd;
      }&#xd;
    },&#xd;
    http_all: function(options, endpoint_descriptor, parameters) {&#xd;
      var doRequest;&#xd;
      doRequest = function() {&#xd;
        var defer, k, promise, request;&#xd;
        defer = $.Deferred();&#xd;
        request = options.oauthio.request || {};&#xd;
        options.headers = options.headers || {};&#xd;
        options.headers.oauthio = "k=" + config.key;&#xd;
        if (options.oauthio.tokens.oauth_token &amp;&amp; options.oauthio.tokens.oauth_token_secret) {&#xd;
          options.headers.oauthio += "&amp;oauthv=1";&#xd;
        }&#xd;
        for (k in options.oauthio.tokens) {&#xd;
          options.headers.oauthio += "&amp;" + encodeURIComponent(k) + "=" + encodeURIComponent(options.oauthio.tokens[k]);&#xd;
        }&#xd;
        delete options.oauthio;&#xd;
        promise = $.ajax(options);&#xd;
        $.when(promise).done(function(data) {&#xd;
          var error;&#xd;
          if (typeof data.data === 'string') {&#xd;
            try {&#xd;
              data.data = JSON.parse(data.data);&#xd;
            } catch (_error) {&#xd;
              error = _error;&#xd;
              data.data = data.data;&#xd;
            } finally {&#xd;
              defer.resolve(data.data);&#xd;
            }&#xd;
          }&#xd;
        }).fail(function(data) {&#xd;
          if (data.responseJSON) {&#xd;
            defer.reject(data.responseJSON.data);&#xd;
          } else {&#xd;
            defer.reject(new Error("An error occured while trying to access the resource"));&#xd;
          }&#xd;
        });&#xd;
        return defer.promise();&#xd;
      };&#xd;
      return doRequest();&#xd;
    },&#xd;
    mkHttp: function(provider, tokens, request, method) {&#xd;
      var base;&#xd;
      base = this;&#xd;
      return function(opts, opts2) {&#xd;
        var i, options;&#xd;
        options = {};&#xd;
        if (typeof opts === "string") {&#xd;
          if (typeof opts2 === "object") {&#xd;
            for (i in opts2) {&#xd;
              options[i] = opts2[i];&#xd;
            }&#xd;
          }&#xd;
          options.url = opts;&#xd;
        } else if (typeof opts === "object") {&#xd;
          for (i in opts) {&#xd;
            options[i] = opts[i];&#xd;
          }&#xd;
        }&#xd;
        options.type = options.type || method;&#xd;
        options.oauthio = {&#xd;
          provider: provider,&#xd;
          tokens: tokens,&#xd;
          request: request&#xd;
        };&#xd;
        return base.http(options);&#xd;
      };&#xd;
    },&#xd;
    mkHttpMe: function(provider, tokens, request, method) {&#xd;
      var base;&#xd;
      base = this;&#xd;
      return function(filter) {&#xd;
        var options;&#xd;
        options = {};&#xd;
        options.type = options.type || method;&#xd;
        options.oauthio = {&#xd;
          provider: provider,&#xd;
          tokens: tokens,&#xd;
          request: request&#xd;
        };&#xd;
        options.data = options.data || {};&#xd;
        options.data.filter = (filter ? filter.join(",") : undefined);&#xd;
        return base.http_me(options);&#xd;
      };&#xd;
    },&#xd;
    mkHttpAll: function(provider, tokens, endpoint_descriptor) {&#xd;
      var base;&#xd;
      base = this;&#xd;
      return function() {&#xd;
        var k, options, th_param, v;&#xd;
        options = {};&#xd;
        options.type = endpoint_descriptor.method;&#xd;
        options.url = config.oauthd_url + endpoint_descriptor.endpoint.replace(':provider', provider);&#xd;
        options.oauthio = {&#xd;
          provider: provider,&#xd;
          tokens: tokens&#xd;
        };&#xd;
        options.data = {};&#xd;
        for (k in arguments) {&#xd;
          v = arguments[k];&#xd;
          th_param = endpoint_descriptor.params[k];&#xd;
          if (th_param != null) {&#xd;
            options.data[th_param.name] = v;&#xd;
          }&#xd;
        }&#xd;
        options.data = options.data || {};&#xd;
        return base.http_all(options, endpoint_descriptor, arguments);&#xd;
      };&#xd;
    },&#xd;
    sendCallback: function(opts, defer) {&#xd;
      var base, data, e, err, i, k, make_res, request, res, tokens, v;&#xd;
      base = this;&#xd;
      data = void 0;&#xd;
      err = void 0;&#xd;
      try {&#xd;
        data = JSON.parse(opts.data);&#xd;
      } catch (_error) {&#xd;
        e = _error;&#xd;
        defer.reject(new Error("Error while parsing result"));&#xd;
        return opts.callback(new Error("Error while parsing result"));&#xd;
      }&#xd;
      if (!data || !data.provider) {&#xd;
        return;&#xd;
      }&#xd;
      if (opts.provider &amp;&amp; data.provider.toLowerCase() !== opts.provider.toLowerCase()) {&#xd;
        err = new Error("Returned provider name does not match asked provider");&#xd;
        defer.reject(err);&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          return opts.callback(err);&#xd;
        } else {&#xd;
          return;&#xd;
        }&#xd;
      }&#xd;
      if (data.status === "error" || data.status === "fail") {&#xd;
        err = new Error(data.message);&#xd;
        err.body = data.data;&#xd;
        defer.reject(err);&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          return opts.callback(err);&#xd;
        } else {&#xd;
          return;&#xd;
        }&#xd;
      }&#xd;
      if (data.status !== "success" || !data.data) {&#xd;
        err = new Error();&#xd;
        err.body = data.data;&#xd;
        defer.reject(err);&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          return opts.callback(err);&#xd;
        } else {&#xd;
          return;&#xd;
        }&#xd;
      }&#xd;
      data.state = data.state.replace(/\s+/g, "");&#xd;
      for (k in client_states) {&#xd;
        v = client_states[k];&#xd;
        try {&#xd;
          client_states[k] = v.replace(/\s+/g, "");&#xd;
        }&#xd;
        catch(err) {&#xd;
          client_states[k] = v;&#xd;
        }&#xd;
      }&#xd;
      if (!data.state || client_states.indexOf(data.state) === -1) {&#xd;
        defer.reject(new Error("State is not matching"));&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          return opts.callback(new Error("State is not matching"));&#xd;
        } else {&#xd;
          return;&#xd;
        }&#xd;
      }&#xd;
      if (!opts.provider) {&#xd;
        data.data.provider = data.provider;&#xd;
      }&#xd;
      res = data.data;&#xd;
      res.provider = data.provider.toLowerCase();&#xd;
      if (cache.cacheEnabled(opts.cache) &amp;&amp; res) {&#xd;
        cache.storeCache(data.provider, res);&#xd;
      }&#xd;
      request = res.request;&#xd;
      delete res.request;&#xd;
      tokens = void 0;&#xd;
      if (res.access_token) {&#xd;
        tokens = {&#xd;
          access_token: res.access_token&#xd;
        };&#xd;
      } else if (res.oauth_token &amp;&amp; res.oauth_token_secret) {&#xd;
        tokens = {&#xd;
          oauth_token: res.oauth_token,&#xd;
          oauth_token_secret: res.oauth_token_secret&#xd;
        };&#xd;
      }&#xd;
      if (!request) {&#xd;
        defer.resolve(res);&#xd;
        if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
          return opts.callback(null, res);&#xd;
        } else {&#xd;
          return;&#xd;
        }&#xd;
      }&#xd;
      if (request.required) {&#xd;
        for (i in request.required) {&#xd;
          tokens[request.required[i]] = res[request.required[i]];&#xd;
        }&#xd;
      }&#xd;
      make_res = function(method) {&#xd;
        return base.mkHttp(data.provider, tokens, request, method);&#xd;
      };&#xd;
      res.toJson = function() {&#xd;
        var a;&#xd;
        a = {};&#xd;
        if (res.access_token != null) {&#xd;
          a.access_token = res.access_token;&#xd;
        }&#xd;
        if (res.oauth_token != null) {&#xd;
          a.oauth_token = res.oauth_token;&#xd;
        }&#xd;
        if (res.oauth_token_secret != null) {&#xd;
          a.oauth_token_secret = res.oauth_token_secret;&#xd;
        }&#xd;
        if (res.expires_in != null) {&#xd;
          a.expires_in = res.expires_in;&#xd;
        }&#xd;
        if (res.token_type != null) {&#xd;
          a.token_type = res.token_type;&#xd;
        }&#xd;
        if (res.id_token != null) {&#xd;
          a.id_token = res.id_token;&#xd;
        }&#xd;
        if (res.provider != null) {&#xd;
          a.provider = res.provider;&#xd;
        }&#xd;
        if (res.email != null) {&#xd;
          a.email = res.email;&#xd;
        }&#xd;
        return a;&#xd;
      };&#xd;
      res.get = make_res("GET");&#xd;
      res.post = make_res("POST");&#xd;
      res.put = make_res("PUT");&#xd;
      res.patch = make_res("PATCH");&#xd;
      res.del = make_res("DELETE");&#xd;
      res.me = base.mkHttpMe(data.provider, tokens, request, "GET");&#xd;
      return this.retrieveMethods().then((function(_this) {&#xd;
        return function() {&#xd;
          _this.generateMethods(res, tokens, data.provider);&#xd;
          defer.resolve(res);&#xd;
          if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
            return opts.callback(null, res);&#xd;
          } else {&#xd;
&#xd;
          }&#xd;
        };&#xd;
      })(this)).fail((function(_this) {&#xd;
        return function(e) {&#xd;
          console.log('Could not retrieve methods', e);&#xd;
          defer.resolve(res);&#xd;
          if (opts.callback &amp;&amp; typeof opts.callback === "function") {&#xd;
            return opts.callback(null, res);&#xd;
          } else {&#xd;
&#xd;
          }&#xd;
        };&#xd;
      })(this));&#xd;
    }&#xd;
  };&#xd;
};&#xd;
&#xd;
},{"../tools/url":14,"q":16}],7:[function(require,module,exports){&#xd;
"use strict";&#xd;
module.exports = function(Materia) {&#xd;
  var $, UserObject, config, cookieStore, lastSave;&#xd;
  $ = Materia.getJquery();&#xd;
  config = Materia.getConfig();&#xd;
  cookieStore = Materia.getCookies();&#xd;
  lastSave = null;&#xd;
  UserObject = (function() {&#xd;
    function UserObject(data) {&#xd;
      this.token = data.token;&#xd;
      this.data = data.user;&#xd;
      this.providers = data.providers;&#xd;
      lastSave = this.getEditableData();&#xd;
    }&#xd;
&#xd;
    UserObject.prototype.getEditableData = function() {&#xd;
      var data, key;&#xd;
      data = [];&#xd;
      for (key in this.data) {&#xd;
        if (['id', 'email'].indexOf(key) === -1) {&#xd;
          data.push({&#xd;
            key: key,&#xd;
            value: this.data[key]&#xd;
          });&#xd;
        }&#xd;
      }&#xd;
      return data;&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.save = function() {&#xd;
      var d, dataToSave, keyIsInLastSave, _i, _j, _len, _len1, _ref;&#xd;
      dataToSave = {};&#xd;
      for (_i = 0, _len = lastSave.length; _i &lt; _len; _i++) {&#xd;
        d = lastSave[_i];&#xd;
        if (this.data[d.key] !== d.value) {&#xd;
          dataToSave[d.key] = this.data[d.key];&#xd;
        }&#xd;
        if (this.data[d.key] === null) {&#xd;
          delete this.data[d.key];&#xd;
        }&#xd;
      }&#xd;
      keyIsInLastSave = function(key) {&#xd;
        var o, _j, _len1;&#xd;
        for (_j = 0, _len1 = lastSave.length; _j &lt; _len1; _j++) {&#xd;
          o = lastSave[_j];&#xd;
          if (o.key === key) {&#xd;
            return true;&#xd;
          }&#xd;
        }&#xd;
        return false;&#xd;
      };&#xd;
      _ref = this.getEditableData();&#xd;
      for (_j = 0, _len1 = _ref.length; _j &lt; _len1; _j++) {&#xd;
        d = _ref[_j];&#xd;
        if (!keyIsInLastSave(d.key)) {&#xd;
          dataToSave[d.key] = this.data[d.key];&#xd;
        }&#xd;
      }&#xd;
      this.saveLocal();&#xd;
      return Materia.API.put('/api/usermanagement/user?k=' + config.key + '&amp;token=' + this.token, dataToSave);&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.select = function(provider) {&#xd;
      var OAuthResult;&#xd;
      OAuthResult = null;&#xd;
      return OAuthResult;&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.saveLocal = function() {&#xd;
      var copy;&#xd;
      copy = {&#xd;
        token: this.token,&#xd;
        user: this.data,&#xd;
        providers: this.providers&#xd;
      };&#xd;
      cookieStore.eraseCookie('oio_auth');&#xd;
      return cookieStore.createCookie('oio_auth', JSON.stringify(copy), 21600);&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.hasProvider = function(provider) {&#xd;
      var _ref;&#xd;
      return ((_ref = this.providers) != null ? _ref.indexOf(provider) : void 0) !== -1;&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.getProviders = function() {&#xd;
      var defer;&#xd;
      defer = $.Deferred();&#xd;
      Materia.API.get('/api/usermanagement/user/providers?k=' + config.key + '&amp;token=' + this.token).done((function(_this) {&#xd;
        return function(providers) {&#xd;
          _this.providers = providers.data;&#xd;
          _this.saveLocal();&#xd;
          return defer.resolve(_this.providers);&#xd;
        };&#xd;
      })(this)).fail(function(err) {&#xd;
        return defer.reject(err);&#xd;
      });&#xd;
      return defer.promise();&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.addProvider = function(oauthRes) {&#xd;
      var defer;&#xd;
      defer = $.Deferred();&#xd;
      if (typeof oauthRes.toJson === 'function') {&#xd;
        oauthRes = oauthRes.toJson();&#xd;
      }&#xd;
      oauthRes.email = this.data.email;&#xd;
      this.providers.push(oauthRes.provider);&#xd;
      Materia.API.post('/api/usermanagement/user/providers?k=' + config.key + '&amp;token=' + this.token, oauthRes).done((function(_this) {&#xd;
        return function(res) {&#xd;
          _this.data = res.data;&#xd;
          _this.saveLocal();&#xd;
          return defer.resolve();&#xd;
        };&#xd;
      })(this)).fail((function(_this) {&#xd;
        return function(err) {&#xd;
          _this.providers.splice(_this.providers.indexOf(oauthRes.provider), 1);&#xd;
          return defer.reject(err);&#xd;
        };&#xd;
      })(this));&#xd;
      return defer.promise();&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.removeProvider = function(provider) {&#xd;
      var defer;&#xd;
      defer = $.Deferred();&#xd;
      this.providers.splice(this.providers.indexOf(provider), 1);&#xd;
      Materia.API.del('/api/usermanagement/user/providers/' + provider + '?k=' + config.key + '&amp;token=' + this.token).done((function(_this) {&#xd;
        return function(res) {&#xd;
          _this.saveLocal();&#xd;
          return defer.resolve(res);&#xd;
        };&#xd;
      })(this)).fail((function(_this) {&#xd;
        return function(err) {&#xd;
          _this.providers.push(provider);&#xd;
          return defer.reject(err);&#xd;
        };&#xd;
      })(this));&#xd;
      return defer.promise();&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.changePassword = function(oldPassword, newPassword) {&#xd;
      return Materia.API.post('/api/usermanagement/user/password?k=' + config.key + '&amp;token=' + this.token, {&#xd;
        password: newPassword&#xd;
      });&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.isLoggued = function() {&#xd;
      return Materia.User.isLogged();&#xd;
    };&#xd;
&#xd;
    UserObject.prototype.logout = function() {&#xd;
      var defer;&#xd;
      defer = $.Deferred();&#xd;
      cookieStore.eraseCookie('oio_auth');&#xd;
      Materia.API.post('/api/usermanagement/user/logout?k=' + config.key + '&amp;token=' + this.token).done(function() {&#xd;
        return defer.resolve();&#xd;
      }).fail(function(err) {&#xd;
        return defer.reject(err);&#xd;
      });&#xd;
      return defer.promise();&#xd;
    };&#xd;
&#xd;
    return UserObject;&#xd;
&#xd;
  })();&#xd;
  return {&#xd;
    initialize: function(public_key, options) {&#xd;
      return Materia.initialize(public_key, options);&#xd;
    },&#xd;
    setOAuthdURL: function(url) {&#xd;
      return Materia.setOAuthdURL(url);&#xd;
    },&#xd;
    signup: function(data) {&#xd;
      var defer;&#xd;
      defer = $.Deferred();&#xd;
      if (typeof data.toJson === 'function') {&#xd;
        data = data.toJson();&#xd;
      }&#xd;
      Materia.API.post('/api/usermanagement/signup?k=' + config.key, data).done(function(res) {&#xd;
        cookieStore.createCookie('oio_auth', JSON.stringify(res.data), res.data.expires_in || 21600);&#xd;
        return defer.resolve(new UserObject(res.data));&#xd;
      }).fail(function(err) {&#xd;
        return defer.reject(err);&#xd;
      });&#xd;
      return defer.promise();&#xd;
    },&#xd;
    signin: function(email, password) {&#xd;
      var defer, signinData;&#xd;
      defer = $.Deferred();&#xd;
      if (typeof email !== "string" &amp;&amp; !password) {&#xd;
        signinData = email;&#xd;
        if (typeof signinData.toJson === 'function') {&#xd;
          signinData = signinData.toJson();&#xd;
        }&#xd;
        Materia.API.post('/api/usermanagement/signin?k=' + config.key, signinData).done(function(res) {&#xd;
          cookieStore.createCookie('oio_auth', JSON.stringify(res.data), res.data.expires_in || 21600);&#xd;
          return defer.resolve(new UserObject(res.data));&#xd;
        }).fail(function(err) {&#xd;
          return defer.reject(err);&#xd;
        });&#xd;
      } else {&#xd;
        Materia.API.post('/api/usermanagement/signin?k=' + config.key, {&#xd;
          email: email,&#xd;
          password: password&#xd;
        }).done(function(res) {&#xd;
          cookieStore.createCookie('oio_auth', JSON.stringify(res.data), res.data.expires_in || 21600);&#xd;
          return defer.resolve(new UserObject(res.data));&#xd;
        }).fail(function(err) {&#xd;
          return defer.reject(err);&#xd;
        });&#xd;
      }&#xd;
      return defer.promise();&#xd;
    },&#xd;
    confirmResetPassword: function(newPassword, key) {&#xd;
      return Materia.API.post('/api/usermanagement/user/password?k=' + config.key + '&amp;token=' + this.token, {&#xd;
        password: newPassword,&#xd;
        passwordKey: key&#xd;
      });&#xd;
    },&#xd;
    resetPassword: function(email, callback) {&#xd;
      return Materia.API.post('/api/usermanagement/password/reset?k=' + config.key, {&#xd;
        email: email&#xd;
      });&#xd;
    },&#xd;
    refreshIdentity: function() {&#xd;
      var defer;&#xd;
      defer = $.Deferred();&#xd;
      Materia.API.get('/api/usermanagement/user?k=' + config.key + '&amp;token=' + cookieStore.readCookie('oio_auth')).done(function(res) {&#xd;
        return defer.resolve(new UserObject(res.data));&#xd;
      }).fail(function(err) {&#xd;
        return defer.reject(err);&#xd;
      });&#xd;
      return defer.promise();&#xd;
    },&#xd;
    getIdentity: function() {&#xd;
      return new UserObject(JSON.parse(cookieStore.readCookie('oio_auth')));&#xd;
    },&#xd;
    isLogged: function() {&#xd;
      var a;&#xd;
      a = cookieStore.readCookie('oio_auth');&#xd;
      if (a) {&#xd;
        return true;&#xd;
      }&#xd;
      return false;&#xd;
    }&#xd;
  };&#xd;
};&#xd;
&#xd;
},{}],8:[function(require,module,exports){&#xd;
(function() {&#xd;
  var Materia, jquery;&#xd;
  jquery = require('./tools/jquery-lite.js');&#xd;
  Materia = require('./lib/core')(window, document, jquery, navigator);&#xd;
  Materia.extend('OAuth', require('./lib/oauth'));&#xd;
  Materia.extend('API', require('./lib/api'));&#xd;
  Materia.extend('User', require('./lib/user'));&#xd;
  if (typeof angular !== "undefined" &amp;&amp; angular !== null) {&#xd;
    angular.module('oauthio', []).factory('Materia', [&#xd;
      function() {&#xd;
        return Materia;&#xd;
      }&#xd;
    ]).factory('OAuth', [&#xd;
      function() {&#xd;
        return Materia.OAuth;&#xd;
      }&#xd;
    ]).factory('User', [&#xd;
      function() {&#xd;
        return Materia.User;&#xd;
      }&#xd;
    ]);&#xd;
  }&#xd;
  window.Materia = Materia;&#xd;
  window.User = window.Materia.User;&#xd;
  return window.OAuth = window.Materia.OAuth;&#xd;
})();&#xd;
&#xd;
},{"./lib/api":2,"./lib/core":3,"./lib/oauth":4,"./lib/user":7,"./tools/jquery-lite.js":11}],9:[function(require,module,exports){&#xd;
"use strict";&#xd;
module.exports = {&#xd;
  init: function(cookies_module, config) {&#xd;
    this.config = config;&#xd;
    return this.cookies = cookies_module;&#xd;
  },&#xd;
  tryCache: function(OAuth, provider, cache) {&#xd;
    var e, i, res;&#xd;
    if (this.cacheEnabled(cache)) {&#xd;
      cache = this.cookies.readCookie("oauthio_provider_" + provider);&#xd;
      if (!cache) {&#xd;
        return false;&#xd;
      }&#xd;
      cache = decodeURIComponent(cache);&#xd;
    }&#xd;
    if (typeof cache === "string") {&#xd;
      try {&#xd;
        cache = JSON.parse(cache);&#xd;
      } catch (_error) {&#xd;
        e = _error;&#xd;
        return false;&#xd;
      }&#xd;
    }&#xd;
    if (typeof cache === "object") {&#xd;
      res = {};&#xd;
      for (i in cache) {&#xd;
        if (i !== "request" &amp;&amp; typeof cache[i] !== "function") {&#xd;
          res[i] = cache[i];&#xd;
        }&#xd;
      }&#xd;
      return OAuth.create(provider, res, cache.request);&#xd;
    }&#xd;
    return false;&#xd;
  },&#xd;
  storeCache: function(provider, cache) {&#xd;
    this.cookies.createCookie("oauthio_provider_" + provider, encodeURIComponent(JSON.stringify(cache)), cache.expires_in - 10 || 3600);&#xd;
  },&#xd;
  cacheEnabled: function(cache) {&#xd;
    if (typeof cache === "undefined") {&#xd;
      return this.config.options.cache;&#xd;
    }&#xd;
    return cache;&#xd;
  }&#xd;
};&#xd;
&#xd;
},{}],10:[function(require,module,exports){&#xd;
"use strict";&#xd;
module.exports = {&#xd;
  init: function(config, document) {&#xd;
    this.config = config;&#xd;
    return this.document = document;&#xd;
  },&#xd;
  createCookie: function(name, value, expires) {&#xd;
    var date;&#xd;
    this.eraseCookie(name);&#xd;
    date = new Date();&#xd;
    date.setTime(date.getTime() + (expires || 1200) * 1000);&#xd;
    expires = "; expires=" + date.toGMTString();&#xd;
    this.document.cookie = name + "=" + value + expires + "; path=/";&#xd;
  },&#xd;
  readCookie: function(name) {&#xd;
    var c, ca, i, nameEQ;&#xd;
    nameEQ = name + "=";&#xd;
    ca = this.document.cookie.split(";");&#xd;
    i = 0;&#xd;
    while (i &lt; ca.length) {&#xd;
      c = ca[i];&#xd;
      while (c.charAt(0) === " ") {&#xd;
        c = c.substring(1, c.length);&#xd;
      }&#xd;
      if (c.indexOf(nameEQ) === 0) {&#xd;
        return c.substring(nameEQ.length, c.length);&#xd;
      }&#xd;
      i++;&#xd;
    }&#xd;
    return null;&#xd;
  },&#xd;
  eraseCookie: function(name) {&#xd;
    var date;&#xd;
    date = new Date();&#xd;
    date.setTime(date.getTime() - 86400000);&#xd;
    this.document.cookie = name + "=; expires=" + date.toGMTString() + "; path=/";&#xd;
  }&#xd;
};&#xd;
&#xd;
},{}],11:[function(require,module,exports){&#xd;
/*!&#xd;
 * jQuery JavaScript Library v2.1.1 -attributes,-attributes/attr,-attributes/classes,-attributes/prop,-attributes/support,-attributes/val,-css/addGetHookIf,-css/curCSS,-css/defaultDisplay,-css/hiddenVisibleSelectors,-css/support,-css/swap,-css/var,-css/var/cssExpand,-css/var/getStyles,-css/var/isHidden,-css/var/rmargin,-css/var/rnumnonpx,-css,-effects,-effects/Tween,-effects/animatedSelector,-dimensions,-offset,-data/var/data_user,-deprecated,-event/alias,-event/support,-intro,-manipulation/_evalUrl,-manipulation/support,-manipulation/var,-manipulation/var/rcheckableType,-manipulation,-outro,-queue,-queue/delay,-selector-native,-selector-sizzle,-sizzle/dist,-sizzle/dist/sizzle,-sizzle/dist/min,-sizzle/test,-sizzle/test/jquery,-traversing,-traversing/findFilter,-traversing/var/rneedsContext,-traversing/var,-wrap,-exports,-exports/amd&#xd;
 * http://jquery.com/&#xd;
 *&#xd;
 * Includes Sizzle.js&#xd;
 * http://sizzlejs.com/&#xd;
 *&#xd;
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors&#xd;
 * Released under the MIT license&#xd;
 * http://jquery.org/license&#xd;
 *&#xd;
 * Date: 2014-09-24T13:40Z&#xd;
 */&#xd;
&#xd;
(function( global, factory ) {&#xd;
&#xd;
	if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" ) {&#xd;
		// For CommonJS and CommonJS-like environments where a proper window is present,&#xd;
		// execute the factory and get jQuery&#xd;
		// For environments that do not inherently posses a window with a document&#xd;
		// (such as Node.js), expose a jQuery-making factory as module.exports&#xd;
		// This accentuates the need for the creation of a real window&#xd;
		// e.g. var jQuery = require("jquery")(window);&#xd;
		// See ticket #14549 for more info&#xd;
		module.exports = global.document ?&#xd;
			factory( global, true ) :&#xd;
			function( w ) {&#xd;
				if ( !w.document ) {&#xd;
					throw new Error( "jQuery requires a window with a document" );&#xd;
				}&#xd;
				return factory( w );&#xd;
			};&#xd;
	} else {&#xd;
		factory( global );&#xd;
	}&#xd;
&#xd;
// Pass this if window is not defined yet&#xd;
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {&#xd;
&#xd;
// Can't do this because several apps including ASP.NET trace&#xd;
// the stack via arguments.caller.callee and Firefox dies if&#xd;
// you try to trace through "use strict" call chains. (#13335)&#xd;
// Support: Firefox 18+&#xd;
//&#xd;
&#xd;
var arr = [];&#xd;
&#xd;
var slice = arr.slice;&#xd;
&#xd;
var concat = arr.concat;&#xd;
&#xd;
var push = arr.push;&#xd;
&#xd;
var indexOf = arr.indexOf;&#xd;
&#xd;
var class2type = {};&#xd;
&#xd;
var toString = class2type.toString;&#xd;
&#xd;
var hasOwn = class2type.hasOwnProperty;&#xd;
&#xd;
var support = {};&#xd;
&#xd;
&#xd;
&#xd;
var&#xd;
	// Use the correct document accordingly with window argument (sandbox)&#xd;
	document = window.document,&#xd;
&#xd;
	version = "2.1.1 -attributes,-attributes/attr,-attributes/classes,-attributes/prop,-attributes/support,-attributes/val,-css/addGetHookIf,-css/curCSS,-css/defaultDisplay,-css/hiddenVisibleSelectors,-css/support,-css/swap,-css/var,-css/var/cssExpand,-css/var/getStyles,-css/var/isHidden,-css/var/rmargin,-css/var/rnumnonpx,-css,-effects,-effects/Tween,-effects/animatedSelector,-dimensions,-offset,-data/var/data_user,-deprecated,-event/alias,-event/support,-intro,-manipulation/_evalUrl,-manipulation/support,-manipulation/var,-manipulation/var/rcheckableType,-manipulation,-outro,-queue,-queue/delay,-selector-native,-selector-sizzle,-sizzle/dist,-sizzle/dist/sizzle,-sizzle/dist/min,-sizzle/test,-sizzle/test/jquery,-traversing,-traversing/findFilter,-traversing/var/rneedsContext,-traversing/var,-wrap,-exports,-exports/amd",&#xd;
&#xd;
	// Define a local copy of jQuery&#xd;
	jQuery = function( selector, context ) {&#xd;
		// The jQuery object is actually just the init constructor 'enhanced'&#xd;
		// Need init if jQuery is called (just allow error to be thrown if not included)&#xd;
		return new jQuery.fn.init( selector, context );&#xd;
	},&#xd;
&#xd;
	// Support: Android&lt;4.1&#xd;
	// Make sure we trim BOM and NBSP&#xd;
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,&#xd;
&#xd;
	// Matches dashed string for camelizing&#xd;
	rmsPrefix = /^-ms-/,&#xd;
	rdashAlpha = /-([\da-z])/gi,&#xd;
&#xd;
	// Used by jQuery.camelCase as callback to replace()&#xd;
	fcamelCase = function( all, letter ) {&#xd;
		return letter.toUpperCase();&#xd;
	};&#xd;
&#xd;
jQuery.fn = jQuery.prototype = {&#xd;
	// The current version of jQuery being used&#xd;
	jquery: version,&#xd;
&#xd;
	constructor: jQuery,&#xd;
&#xd;
	// Start with an empty selector&#xd;
	selector: "",&#xd;
&#xd;
	// The default length of a jQuery object is 0&#xd;
	length: 0,&#xd;
&#xd;
	toArray: function() {&#xd;
		return slice.call( this );&#xd;
	},&#xd;
&#xd;
	// Get the Nth element in the matched element set OR&#xd;
	// Get the whole matched element set as a clean array&#xd;
	get: function( num ) {&#xd;
		return num != null ?&#xd;
&#xd;
			// Return just the one element from the set&#xd;
			( num &lt; 0 ? this[ num + this.length ] : this[ num ] ) :&#xd;
&#xd;
			// Return all the elements in a clean array&#xd;
			slice.call( this );&#xd;
	},&#xd;
&#xd;
	// Take an array of elements and push it onto the stack&#xd;
	// (returning the new matched element set)&#xd;
	pushStack: function( elems ) {&#xd;
&#xd;
		// Build a new jQuery matched element set&#xd;
		var ret = jQuery.merge( this.constructor(), elems );&#xd;
&#xd;
		// Add the old object onto the stack (as a reference)&#xd;
		ret.prevObject = this;&#xd;
		ret.context = this.context;&#xd;
&#xd;
		// Return the newly-formed element set&#xd;
		return ret;&#xd;
	},&#xd;
&#xd;
	// Execute a callback for every element in the matched set.&#xd;
	// (You can seed the arguments with an array of args, but this is&#xd;
	// only used internally.)&#xd;
	each: function( callback, args ) {&#xd;
		return jQuery.each( this, callback, args );&#xd;
	},&#xd;
&#xd;
	map: function( callback ) {&#xd;
		return this.pushStack( jQuery.map(this, function( elem, i ) {&#xd;
			return callback.call( elem, i, elem );&#xd;
		}));&#xd;
	},&#xd;
&#xd;
	slice: function() {&#xd;
		return this.pushStack( slice.apply( this, arguments ) );&#xd;
	},&#xd;
&#xd;
	first: function() {&#xd;
		return this.eq( 0 );&#xd;
	},&#xd;
&#xd;
	last: function() {&#xd;
		return this.eq( -1 );&#xd;
	},&#xd;
&#xd;
	eq: function( i ) {&#xd;
		var len = this.length,&#xd;
			j = +i + ( i &lt; 0 ? len : 0 );&#xd;
		return this.pushStack( j >= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );&#xd;
	},&#xd;
&#xd;
	end: function() {&#xd;
		return this.prevObject || this.constructor(null);&#xd;
	},&#xd;
&#xd;
	// For internal use only.&#xd;
	// Behaves like an Array's method, not like a jQuery method.&#xd;
	push: push,&#xd;
	sort: arr.sort,&#xd;
	splice: arr.splice&#xd;
};&#xd;
&#xd;
jQuery.extend = jQuery.fn.extend = function() {&#xd;
	var options, name, src, copy, copyIsArray, clone,&#xd;
		target = arguments[0] || {},&#xd;
		i = 1,&#xd;
		length = arguments.length,&#xd;
		deep = false;&#xd;
&#xd;
	// Handle a deep copy situation&#xd;
	if ( typeof target === "boolean" ) {&#xd;
		deep = target;&#xd;
&#xd;
		// skip the boolean and the target&#xd;
		target = arguments[ i ] || {};&#xd;
		i++;&#xd;
	}&#xd;
&#xd;
	// Handle case when target is a string or something (possible in deep copy)&#xd;
	if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction(target) ) {&#xd;
		target = {};&#xd;
	}&#xd;
&#xd;
	// extend jQuery itself if only one argument is passed&#xd;
	if ( i === length ) {&#xd;
		target = this;&#xd;
		i--;&#xd;
	}&#xd;
&#xd;
	for ( ; i &lt; length; i++ ) {&#xd;
		// Only deal with non-null/undefined values&#xd;
		if ( (options = arguments[ i ]) != null ) {&#xd;
			// Extend the base object&#xd;
			for ( name in options ) {&#xd;
				src = target[ name ];&#xd;
				copy = options[ name ];&#xd;
&#xd;
				// Prevent never-ending loop&#xd;
				if ( target === copy ) {&#xd;
					continue;&#xd;
				}&#xd;
&#xd;
				// Recurse if we're merging plain objects or arrays&#xd;
				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {&#xd;
					if ( copyIsArray ) {&#xd;
						copyIsArray = false;&#xd;
						clone = src &amp;&amp; jQuery.isArray(src) ? src : [];&#xd;
&#xd;
					} else {&#xd;
						clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};&#xd;
					}&#xd;
&#xd;
					// Never move original objects, clone them&#xd;
					target[ name ] = jQuery.extend( deep, clone, copy );&#xd;
&#xd;
				// Don't bring in undefined values&#xd;
				} else if ( copy !== undefined ) {&#xd;
					target[ name ] = copy;&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
	}&#xd;
&#xd;
	// Return the modified object&#xd;
	return target;&#xd;
};&#xd;
&#xd;
jQuery.extend({&#xd;
	// Unique for each copy of jQuery on the page&#xd;
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),&#xd;
&#xd;
	// Assume jQuery is ready without the ready module&#xd;
	isReady: true,&#xd;
&#xd;
	error: function( msg ) {&#xd;
		throw new Error( msg );&#xd;
	},&#xd;
&#xd;
	noop: function() {},&#xd;
&#xd;
	// See test/unit/core.js for details concerning isFunction.&#xd;
	// Since version 1.3, DOM methods and functions like alert&#xd;
	// aren't supported. They return false on IE (#2968).&#xd;
	isFunction: function( obj ) {&#xd;
		return jQuery.type(obj) === "function";&#xd;
	},&#xd;
&#xd;
	isArray: Array.isArray,&#xd;
&#xd;
	isWindow: function( obj ) {&#xd;
		return obj != null &amp;&amp; obj === obj.window;&#xd;
	},&#xd;
&#xd;
	isNumeric: function( obj ) {&#xd;
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")&#xd;
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")&#xd;
		// subtraction forces infinities to NaN&#xd;
		return !jQuery.isArray( obj ) &amp;&amp; obj - parseFloat( obj ) >= 0;&#xd;
	},&#xd;
&#xd;
	isPlainObject: function( obj ) {&#xd;
		// Not plain objects:&#xd;
		// - Any object or value whose internal [[Class]] property is not "[object Object]"&#xd;
		// - DOM nodes&#xd;
		// - window&#xd;
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {&#xd;
			return false;&#xd;
		}&#xd;
&#xd;
		if ( obj.constructor &amp;&amp;&#xd;
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {&#xd;
			return false;&#xd;
		}&#xd;
&#xd;
		// If the function hasn't returned already, we're confident that&#xd;
		// |obj| is a plain object, created by {} or constructed with new Object&#xd;
		return true;&#xd;
	},&#xd;
&#xd;
	isEmptyObject: function( obj ) {&#xd;
		var name;&#xd;
		for ( name in obj ) {&#xd;
			return false;&#xd;
		}&#xd;
		return true;&#xd;
	},&#xd;
&#xd;
	type: function( obj ) {&#xd;
		if ( obj == null ) {&#xd;
			return obj + "";&#xd;
		}&#xd;
		// Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)&#xd;
		return typeof obj === "object" || typeof obj === "function" ?&#xd;
			class2type[ toString.call(obj) ] || "object" :&#xd;
			typeof obj;&#xd;
	},&#xd;
&#xd;
	// Evaluates a script in a global context&#xd;
	globalEval: function( code ) {&#xd;
		var script,&#xd;
			indirect = eval;&#xd;
&#xd;
		code = jQuery.trim( code );&#xd;
&#xd;
		if ( code ) {&#xd;
			// If the code includes a valid, prologue position&#xd;
			// strict mode pragma, execute code by injecting a&#xd;
			// script tag into the document.&#xd;
			if ( code.indexOf("use strict") === 1 ) {&#xd;
				script = document.createElement("script");&#xd;
				script.text = code;&#xd;
				document.head.appendChild( script ).parentNode.removeChild( script );&#xd;
			} else {&#xd;
			// Otherwise, avoid the DOM node creation, insertion&#xd;
			// and removal by using an indirect global eval&#xd;
				indirect( code );&#xd;
			}&#xd;
		}&#xd;
	},&#xd;
&#xd;
	// Convert dashed to camelCase; used by the css and data modules&#xd;
	// Microsoft forgot to hump their vendor prefix (#9572)&#xd;
	camelCase: function( string ) {&#xd;
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );&#xd;
	},&#xd;
&#xd;
	nodeName: function( elem, name ) {&#xd;
		return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();&#xd;
	},&#xd;
&#xd;
	// args is for internal usage only&#xd;
	each: function( obj, callback, args ) {&#xd;
		var value,&#xd;
			i = 0,&#xd;
			length = obj.length,&#xd;
			isArray = isArraylike( obj );&#xd;
&#xd;
		if ( args ) {&#xd;
			if ( isArray ) {&#xd;
				for ( ; i &lt; length; i++ ) {&#xd;
					value = callback.apply( obj[ i ], args );&#xd;
&#xd;
					if ( value === false ) {&#xd;
						break;&#xd;
					}&#xd;
				}&#xd;
			} else {&#xd;
				for ( i in obj ) {&#xd;
					value = callback.apply( obj[ i ], args );&#xd;
&#xd;
					if ( value === false ) {&#xd;
						break;&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
&#xd;
		// A special, fast, case for the most common use of each&#xd;
		} else {&#xd;
			if ( isArray ) {&#xd;
				for ( ; i &lt; length; i++ ) {&#xd;
					value = callback.call( obj[ i ], i, obj[ i ] );&#xd;
&#xd;
					if ( value === false ) {&#xd;
						break;&#xd;
					}&#xd;
				}&#xd;
			} else {&#xd;
				for ( i in obj ) {&#xd;
					value = callback.call( obj[ i ], i, obj[ i ] );&#xd;
&#xd;
					if ( value === false ) {&#xd;
						break;&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		return obj;&#xd;
	},&#xd;
&#xd;
	// Support: Android&lt;4.1&#xd;
	trim: function( text ) {&#xd;
		return text == null ?&#xd;
			"" :&#xd;
			( text + "" ).replace( rtrim, "" );&#xd;
	},&#xd;
&#xd;
	// results is for internal usage only&#xd;
	makeArray: function( arr, results ) {&#xd;
		var ret = results || [];&#xd;
&#xd;
		if ( arr != null ) {&#xd;
			if ( isArraylike( Object(arr) ) ) {&#xd;
				jQuery.merge( ret,&#xd;
					typeof arr === "string" ?&#xd;
					[ arr ] : arr&#xd;
				);&#xd;
			} else {&#xd;
				push.call( ret, arr );&#xd;
			}&#xd;
		}&#xd;
&#xd;
		return ret;&#xd;
	},&#xd;
&#xd;
	inArray: function( elem, arr, i ) {&#xd;
		return arr == null ? -1 : indexOf.call( arr, elem, i );&#xd;
	},&#xd;
&#xd;
	merge: function( first, second ) {&#xd;
		var len = +second.length,&#xd;
			j = 0,&#xd;
			i = first.length;&#xd;
&#xd;
		for ( ; j &lt; len; j++ ) {&#xd;
			first[ i++ ] = second[ j ];&#xd;
		}&#xd;
&#xd;
		first.length = i;&#xd;
&#xd;
		return first;&#xd;
	},&#xd;
&#xd;
	grep: function( elems, callback, invert ) {&#xd;
		var callbackInverse,&#xd;
			matches = [],&#xd;
			i = 0,&#xd;
			length = elems.length,&#xd;
			callbackExpect = !invert;&#xd;
&#xd;
		// Go through the array, only saving the items&#xd;
		// that pass the validator function&#xd;
		for ( ; i &lt; length; i++ ) {&#xd;
			callbackInverse = !callback( elems[ i ], i );&#xd;
			if ( callbackInverse !== callbackExpect ) {&#xd;
				matches.push( elems[ i ] );&#xd;
			}&#xd;
		}&#xd;
&#xd;
		return matches;&#xd;
	},&#xd;
&#xd;
	// arg is for internal usage only&#xd;
	map: function( elems, callback, arg ) {&#xd;
		var value,&#xd;
			i = 0,&#xd;
			length = elems.length,&#xd;
			isArray = isArraylike( elems ),&#xd;
			ret = [];&#xd;
&#xd;
		// Go through the array, translating each of the items to their new values&#xd;
		if ( isArray ) {&#xd;
			for ( ; i &lt; length; i++ ) {&#xd;
				value = callback( elems[ i ], i, arg );&#xd;
&#xd;
				if ( value != null ) {&#xd;
					ret.push( value );&#xd;
				}&#xd;
			}&#xd;
&#xd;
		// Go through every key on the object,&#xd;
		} else {&#xd;
			for ( i in elems ) {&#xd;
				value = callback( elems[ i ], i, arg );&#xd;
&#xd;
				if ( value != null ) {&#xd;
					ret.push( value );&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Flatten any nested arrays&#xd;
		return concat.apply( [], ret );&#xd;
	},&#xd;
&#xd;
	// A global GUID counter for objects&#xd;
	guid: 1,&#xd;
&#xd;
	// Bind a function to a context, optionally partially applying any&#xd;
	// arguments.&#xd;
	proxy: function( fn, context ) {&#xd;
		var tmp, args, proxy;&#xd;
&#xd;
		if ( typeof context === "string" ) {&#xd;
			tmp = fn[ context ];&#xd;
			context = fn;&#xd;
			fn = tmp;&#xd;
		}&#xd;
&#xd;
		// Quick check to determine if target is callable, in the spec&#xd;
		// this throws a TypeError, but we will just return undefined.&#xd;
		if ( !jQuery.isFunction( fn ) ) {&#xd;
			return undefined;&#xd;
		}&#xd;
&#xd;
		// Simulated bind&#xd;
		args = slice.call( arguments, 2 );&#xd;
		proxy = function() {&#xd;
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );&#xd;
		};&#xd;
&#xd;
		// Set the guid of unique handler to the same of original handler, so it can be removed&#xd;
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;&#xd;
&#xd;
		return proxy;&#xd;
	},&#xd;
&#xd;
	now: Date.now,&#xd;
&#xd;
	// jQuery.support is not used in Core but other projects attach their&#xd;
	// properties to it so it needs to exist.&#xd;
	support: support&#xd;
});&#xd;
&#xd;
// Populate the class2type map&#xd;
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {&#xd;
	class2type[ "[object " + name + "]" ] = name.toLowerCase();&#xd;
});&#xd;
&#xd;
function isArraylike( obj ) {&#xd;
	var length = obj.length,&#xd;
		type = jQuery.type( obj );&#xd;
&#xd;
	if ( type === "function" || jQuery.isWindow( obj ) ) {&#xd;
		return false;&#xd;
	}&#xd;
&#xd;
	if ( obj.nodeType === 1 &amp;&amp; length ) {&#xd;
		return true;&#xd;
	}&#xd;
&#xd;
	return type === "array" || length === 0 ||&#xd;
		typeof length === "number" &amp;&amp; length > 0 &amp;&amp; ( length - 1 ) in obj;&#xd;
}&#xd;
&#xd;
var rsingleTag = (/^&lt;(\w+)\s*\/?>(?:&lt;\/\1>|)$/);&#xd;
&#xd;
// Initialize a jQuery object&#xd;
&#xd;
&#xd;
// A central reference to the root jQuery(document)&#xd;
var rootjQuery,&#xd;
&#xd;
	// A simple way to check for HTML strings&#xd;
	// Prioritize #id over &lt;tag> to avoid XSS via location.hash (#9521)&#xd;
	// Strict HTML recognition (#11290: must start with &lt;)&#xd;
	rquickExpr = /^(?:\s*(&lt;[\w\W]+>)[^>]*|#([\w-]*))$/,&#xd;
&#xd;
	init = jQuery.fn.init = function( selector, context ) {&#xd;
		var match, elem;&#xd;
&#xd;
		// HANDLE: $(""), $(null), $(undefined), $(false)&#xd;
		if ( !selector ) {&#xd;
			return this;&#xd;
		}&#xd;
&#xd;
		// Handle HTML strings&#xd;
		if ( typeof selector === "string" ) {&#xd;
			if ( selector[0] === "&lt;" &amp;&amp; selector[ selector.length - 1 ] === ">" &amp;&amp; selector.length >= 3 ) {&#xd;
				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check&#xd;
				match = [ null, selector, null ];&#xd;
&#xd;
			} else {&#xd;
				match = rquickExpr.exec( selector );&#xd;
			}&#xd;
&#xd;
			// Match html or make sure no context is specified for #id&#xd;
			if ( match &amp;&amp; (match[1] || !context) ) {&#xd;
&#xd;
				// HANDLE: $(html) -> $(array)&#xd;
				if ( match[1] ) {&#xd;
					context = context instanceof jQuery ? context[0] : context;&#xd;
&#xd;
					// scripts is true for back-compat&#xd;
					// Intentionally let the error be thrown if parseHTML is not present&#xd;
					jQuery.merge( this, jQuery.parseHTML(&#xd;
						match[1],&#xd;
						context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,&#xd;
						true&#xd;
					) );&#xd;
&#xd;
					// HANDLE: $(html, props)&#xd;
					if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) {&#xd;
						for ( match in context ) {&#xd;
							// Properties of context are called as methods if possible&#xd;
							if ( jQuery.isFunction( this[ match ] ) ) {&#xd;
								this[ match ]( context[ match ] );&#xd;
&#xd;
							// ...and otherwise set as attributes&#xd;
							} else {&#xd;
								this.attr( match, context[ match ] );&#xd;
							}&#xd;
						}&#xd;
					}&#xd;
&#xd;
					return this;&#xd;
&#xd;
				// HANDLE: $(#id)&#xd;
				} else {&#xd;
					elem = document.getElementById( match[2] );&#xd;
&#xd;
					// Check parentNode to catch when Blackberry 4.6 returns&#xd;
					// nodes that are no longer in the document #6963&#xd;
					if ( elem &amp;&amp; elem.parentNode ) {&#xd;
						// Inject the element directly into the jQuery object&#xd;
						this.length = 1;&#xd;
						this[0] = elem;&#xd;
					}&#xd;
&#xd;
					this.context = document;&#xd;
					this.selector = selector;&#xd;
					return this;&#xd;
				}&#xd;
&#xd;
			// HANDLE: $(expr, $(...))&#xd;
			} else if ( !context || context.jquery ) {&#xd;
				return ( context || rootjQuery ).find( selector );&#xd;
&#xd;
			// HANDLE: $(expr, context)&#xd;
			// (which is just equivalent to: $(context).find(expr)&#xd;
			} else {&#xd;
				return this.constructor( context ).find( selector );&#xd;
			}&#xd;
&#xd;
		// HANDLE: $(DOMElement)&#xd;
		} else if ( selector.nodeType ) {&#xd;
			this.context = this[0] = selector;&#xd;
			this.length = 1;&#xd;
			return this;&#xd;
&#xd;
		// HANDLE: $(function)&#xd;
		// Shortcut for document ready&#xd;
		} else if ( jQuery.isFunction( selector ) ) {&#xd;
			return typeof rootjQuery.ready !== "undefined" ?&#xd;
				rootjQuery.ready( selector ) :&#xd;
				// Execute immediately if ready is not present&#xd;
				selector( jQuery );&#xd;
		}&#xd;
&#xd;
		if ( selector.selector !== undefined ) {&#xd;
			this.selector = selector.selector;&#xd;
			this.context = selector.context;&#xd;
		}&#xd;
&#xd;
		return jQuery.makeArray( selector, this );&#xd;
	};&#xd;
&#xd;
// Give the init function the jQuery prototype for later instantiation&#xd;
init.prototype = jQuery.fn;&#xd;
&#xd;
// Initialize central reference&#xd;
rootjQuery = jQuery( document );&#xd;
var rnotwhite = (/\S+/g);&#xd;
&#xd;
&#xd;
&#xd;
// String to Object options format cache&#xd;
var optionsCache = {};&#xd;
&#xd;
// Convert String-formatted options into Object-formatted ones and store in cache&#xd;
function createOptions( options ) {&#xd;
	var object = optionsCache[ options ] = {};&#xd;
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {&#xd;
		object[ flag ] = true;&#xd;
	});&#xd;
	return object;&#xd;
}&#xd;
&#xd;
/*&#xd;
 * Create a callback list using the following parameters:&#xd;
 *&#xd;
 *	options: an optional list of space-separated options that will change how&#xd;
 *			the callback list behaves or a more traditional option object&#xd;
 *&#xd;
 * By default a callback list will act like an event callback list and can be&#xd;
 * "fired" multiple times.&#xd;
 *&#xd;
 * Possible options:&#xd;
 *&#xd;
 *	once:			will ensure the callback list can only be fired once (like a Deferred)&#xd;
 *&#xd;
 *	memory:			will keep track of previous values and will call any callback added&#xd;
 *					after the list has been fired right away with the latest "memorized"&#xd;
 *					values (like a Deferred)&#xd;
 *&#xd;
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)&#xd;
 *&#xd;
 *	stopOnFalse:	interrupt callings when a callback returns false&#xd;
 *&#xd;
 */&#xd;
jQuery.Callbacks = function( options ) {&#xd;
&#xd;
	// Convert options from String-formatted to Object-formatted if needed&#xd;
	// (we check in cache first)&#xd;
	options = typeof options === "string" ?&#xd;
		( optionsCache[ options ] || createOptions( options ) ) :&#xd;
		jQuery.extend( {}, options );&#xd;
&#xd;
	var // Last fire value (for non-forgettable lists)&#xd;
		memory,&#xd;
		// Flag to know if list was already fired&#xd;
		fired,&#xd;
		// Flag to know if list is currently firing&#xd;
		firing,&#xd;
		// First callback to fire (used internally by add and fireWith)&#xd;
		firingStart,&#xd;
		// End of the loop when firing&#xd;
		firingLength,&#xd;
		// Index of currently firing callback (modified by remove if needed)&#xd;
		firingIndex,&#xd;
		// Actual callback list&#xd;
		list = [],&#xd;
		// Stack of fire calls for repeatable lists&#xd;
		stack = !options.once &amp;&amp; [],&#xd;
		// Fire callbacks&#xd;
		fire = function( data ) {&#xd;
			memory = options.memory &amp;&amp; data;&#xd;
			fired = true;&#xd;
			firingIndex = firingStart || 0;&#xd;
			firingStart = 0;&#xd;
			firingLength = list.length;&#xd;
			firing = true;&#xd;
			for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {&#xd;
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {&#xd;
					memory = false; // To prevent further calls using add&#xd;
					break;&#xd;
				}&#xd;
			}&#xd;
			firing = false;&#xd;
			if ( list ) {&#xd;
				if ( stack ) {&#xd;
					if ( stack.length ) {&#xd;
						fire( stack.shift() );&#xd;
					}&#xd;
				} else if ( memory ) {&#xd;
					list = [];&#xd;
				} else {&#xd;
					self.disable();&#xd;
				}&#xd;
			}&#xd;
		},&#xd;
		// Actual Callbacks object&#xd;
		self = {&#xd;
			// Add a callback or a collection of callbacks to the list&#xd;
			add: function() {&#xd;
				if ( list ) {&#xd;
					// First, we save the current length&#xd;
					var start = list.length;&#xd;
					(function add( args ) {&#xd;
						jQuery.each( args, function( _, arg ) {&#xd;
							var type = jQuery.type( arg );&#xd;
							if ( type === "function" ) {&#xd;
								if ( !options.unique || !self.has( arg ) ) {&#xd;
									list.push( arg );&#xd;
								}&#xd;
							} else if ( arg &amp;&amp; arg.length &amp;&amp; type !== "string" ) {&#xd;
								// Inspect recursively&#xd;
								add( arg );&#xd;
							}&#xd;
						});&#xd;
					})( arguments );&#xd;
					// Do we need to add the callbacks to the&#xd;
					// current firing batch?&#xd;
					if ( firing ) {&#xd;
						firingLength = list.length;&#xd;
					// With memory, if we're not firing then&#xd;
					// we should call right away&#xd;
					} else if ( memory ) {&#xd;
						firingStart = start;&#xd;
						fire( memory );&#xd;
					}&#xd;
				}&#xd;
				return this;&#xd;
			},&#xd;
			// Remove a callback from the list&#xd;
			remove: function() {&#xd;
				if ( list ) {&#xd;
					jQuery.each( arguments, function( _, arg ) {&#xd;
						var index;&#xd;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {&#xd;
							list.splice( index, 1 );&#xd;
							// Handle firing indexes&#xd;
							if ( firing ) {&#xd;
								if ( index &lt;= firingLength ) {&#xd;
									firingLength--;&#xd;
								}&#xd;
								if ( index &lt;= firingIndex ) {&#xd;
									firingIndex--;&#xd;
								}&#xd;
							}&#xd;
						}&#xd;
					});&#xd;
				}&#xd;
				return this;&#xd;
			},&#xd;
			// Check if a given callback is in the list.&#xd;
			// If no argument is given, return whether or not list has callbacks attached.&#xd;
			has: function( fn ) {&#xd;
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list &amp;&amp; list.length );&#xd;
			},&#xd;
			// Remove all callbacks from the list&#xd;
			empty: function() {&#xd;
				list = [];&#xd;
				firingLength = 0;&#xd;
				return this;&#xd;
			},&#xd;
			// Have the list do nothing anymore&#xd;
			disable: function() {&#xd;
				list = stack = memory = undefined;&#xd;
				return this;&#xd;
			},&#xd;
			// Is it disabled?&#xd;
			disabled: function() {&#xd;
				return !list;&#xd;
			},&#xd;
			// Lock the list in its current state&#xd;
			lock: function() {&#xd;
				stack = undefined;&#xd;
				if ( !memory ) {&#xd;
					self.disable();&#xd;
				}&#xd;
				return this;&#xd;
			},&#xd;
			// Is it locked?&#xd;
			locked: function() {&#xd;
				return !stack;&#xd;
			},&#xd;
			// Call all callbacks with the given context and arguments&#xd;
			fireWith: function( context, args ) {&#xd;
				if ( list &amp;&amp; ( !fired || stack ) ) {&#xd;
					args = args || [];&#xd;
					args = [ context, args.slice ? args.slice() : args ];&#xd;
					if ( firing ) {&#xd;
						stack.push( args );&#xd;
					} else {&#xd;
						fire( args );&#xd;
					}&#xd;
				}&#xd;
				return this;&#xd;
			},&#xd;
			// Call all the callbacks with the given arguments&#xd;
			fire: function() {&#xd;
				self.fireWith( this, arguments );&#xd;
				return this;&#xd;
			},&#xd;
			// To know if the callbacks have already been called at least once&#xd;
			fired: function() {&#xd;
				return !!fired;&#xd;
			}&#xd;
		};&#xd;
&#xd;
	return self;&#xd;
};&#xd;
&#xd;
&#xd;
jQuery.extend({&#xd;
&#xd;
	Deferred: function( func ) {&#xd;
		var tuples = [&#xd;
				// action, add listener, listener list, final state&#xd;
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],&#xd;
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],&#xd;
				[ "notify", "progress", jQuery.Callbacks("memory") ]&#xd;
			],&#xd;
			state = "pending",&#xd;
			promise = {&#xd;
				state: function() {&#xd;
					return state;&#xd;
				},&#xd;
				always: function() {&#xd;
					deferred.done( arguments ).fail( arguments );&#xd;
					return this;&#xd;
				},&#xd;
				then: function( /* fnDone, fnFail, fnProgress */ ) {&#xd;
					var fns = arguments;&#xd;
					return jQuery.Deferred(function( newDefer ) {&#xd;
						jQuery.each( tuples, function( i, tuple ) {&#xd;
							var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];&#xd;
							// deferred[ done | fail | progress ] for forwarding actions to newDefer&#xd;
							deferred[ tuple[1] ](function() {&#xd;
								var returned = fn &amp;&amp; fn.apply( this, arguments );&#xd;
								if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {&#xd;
									returned.promise()&#xd;
										.done( newDefer.resolve )&#xd;
										.fail( newDefer.reject )&#xd;
										.progress( newDefer.notify );&#xd;
								} else {&#xd;
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );&#xd;
								}&#xd;
							});&#xd;
						});&#xd;
						fns = null;&#xd;
					}).promise();&#xd;
				},&#xd;
				// Get a promise for this deferred&#xd;
				// If obj is provided, the promise aspect is added to the object&#xd;
				promise: function( obj ) {&#xd;
					return obj != null ? jQuery.extend( obj, promise ) : promise;&#xd;
				}&#xd;
			},&#xd;
			deferred = {};&#xd;
&#xd;
		// Keep pipe for back-compat&#xd;
		promise.pipe = promise.then;&#xd;
&#xd;
		// Add list-specific methods&#xd;
		jQuery.each( tuples, function( i, tuple ) {&#xd;
			var list = tuple[ 2 ],&#xd;
				stateString = tuple[ 3 ];&#xd;
&#xd;
			// promise[ done | fail | progress ] = list.add&#xd;
			promise[ tuple[1] ] = list.add;&#xd;
&#xd;
			// Handle state&#xd;
			if ( stateString ) {&#xd;
				list.add(function() {&#xd;
					// state = [ resolved | rejected ]&#xd;
					state = stateString;&#xd;
&#xd;
				// [ reject_list | resolve_list ].disable; progress_list.lock&#xd;
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );&#xd;
			}&#xd;
&#xd;
			// deferred[ resolve | reject | notify ]&#xd;
			deferred[ tuple[0] ] = function() {&#xd;
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );&#xd;
				return this;&#xd;
			};&#xd;
			deferred[ tuple[0] + "With" ] = list.fireWith;&#xd;
		});&#xd;
&#xd;
		// Make the deferred a promise&#xd;
		promise.promise( deferred );&#xd;
&#xd;
		// Call given func if any&#xd;
		if ( func ) {&#xd;
			func.call( deferred, deferred );&#xd;
		}&#xd;
&#xd;
		// All done!&#xd;
		return deferred;&#xd;
	},&#xd;
&#xd;
	// Deferred helper&#xd;
	when: function( subordinate /* , ..., subordinateN */ ) {&#xd;
		var i = 0,&#xd;
			resolveValues = slice.call( arguments ),&#xd;
			length = resolveValues.length,&#xd;
&#xd;
			// the count of uncompleted subordinates&#xd;
			remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,&#xd;
&#xd;
			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.&#xd;
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),&#xd;
&#xd;
			// Update function for both resolve and progress values&#xd;
			updateFunc = function( i, contexts, values ) {&#xd;
				return function( value ) {&#xd;
					contexts[ i ] = this;&#xd;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;&#xd;
					if ( values === progressValues ) {&#xd;
						deferred.notifyWith( contexts, values );&#xd;
					} else if ( !( --remaining ) ) {&#xd;
						deferred.resolveWith( contexts, values );&#xd;
					}&#xd;
				};&#xd;
			},&#xd;
&#xd;
			progressValues, progressContexts, resolveContexts;&#xd;
&#xd;
		// add listeners to Deferred subordinates; treat others as resolved&#xd;
		if ( length > 1 ) {&#xd;
			progressValues = new Array( length );&#xd;
			progressContexts = new Array( length );&#xd;
			resolveContexts = new Array( length );&#xd;
			for ( ; i &lt; length; i++ ) {&#xd;
				if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {&#xd;
					resolveValues[ i ].promise()&#xd;
						.done( updateFunc( i, resolveContexts, resolveValues ) )&#xd;
						.fail( deferred.reject )&#xd;
						.progress( updateFunc( i, progressContexts, progressValues ) );&#xd;
				} else {&#xd;
					--remaining;&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// if we're not waiting on anything, resolve the master&#xd;
		if ( !remaining ) {&#xd;
			deferred.resolveWith( resolveContexts, resolveValues );&#xd;
		}&#xd;
&#xd;
		return deferred.promise();&#xd;
	}&#xd;
});&#xd;
&#xd;
&#xd;
// The deferred used on DOM ready&#xd;
var readyList;&#xd;
&#xd;
jQuery.fn.ready = function( fn ) {&#xd;
	// Add the callback&#xd;
	jQuery.ready.promise().done( fn );&#xd;
&#xd;
	return this;&#xd;
};&#xd;
&#xd;
jQuery.extend({&#xd;
	// Is the DOM ready to be used? Set to true once it occurs.&#xd;
	isReady: false,&#xd;
&#xd;
	// A counter to track how many items to wait for before&#xd;
	// the ready event fires. See #6781&#xd;
	readyWait: 1,&#xd;
&#xd;
	// Hold (or release) the ready event&#xd;
	holdReady: function( hold ) {&#xd;
		if ( hold ) {&#xd;
			jQuery.readyWait++;&#xd;
		} else {&#xd;
			jQuery.ready( true );&#xd;
		}&#xd;
	},&#xd;
&#xd;
	// Handle when the DOM is ready&#xd;
	ready: function( wait ) {&#xd;
&#xd;
		// Abort if there are pending holds or we're already ready&#xd;
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// Remember that the DOM is ready&#xd;
		jQuery.isReady = true;&#xd;
&#xd;
		// If a normal DOM Ready event fired, decrement, and wait if need be&#xd;
		if ( wait !== true &amp;&amp; --jQuery.readyWait > 0 ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// If there are functions bound, to execute&#xd;
		readyList.resolveWith( document, [ jQuery ] );&#xd;
&#xd;
		// Trigger any bound ready events&#xd;
		if ( jQuery.fn.triggerHandler ) {&#xd;
			jQuery( document ).triggerHandler( "ready" );&#xd;
			jQuery( document ).off( "ready" );&#xd;
		}&#xd;
	}&#xd;
});&#xd;
&#xd;
/**&#xd;
 * The ready event handler and self cleanup method&#xd;
 */&#xd;
function completed() {&#xd;
	document.removeEventListener( "DOMContentLoaded", completed, false );&#xd;
	window.removeEventListener( "load", completed, false );&#xd;
	jQuery.ready();&#xd;
}&#xd;
&#xd;
jQuery.ready.promise = function( obj ) {&#xd;
	if ( !readyList ) {&#xd;
&#xd;
		readyList = jQuery.Deferred();&#xd;
&#xd;
		// Catch cases where $(document).ready() is called after the browser event has already occurred.&#xd;
		// we once tried to use readyState "interactive" here, but it caused issues like the one&#xd;
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15&#xd;
		if ( document.readyState === "complete" ) {&#xd;
			// Handle it asynchronously to allow scripts the opportunity to delay ready&#xd;
			setTimeout( jQuery.ready );&#xd;
&#xd;
		} else {&#xd;
&#xd;
			// Use the handy event callback&#xd;
			document.addEventListener( "DOMContentLoaded", completed, false );&#xd;
&#xd;
			// A fallback to window.onload, that will always work&#xd;
			window.addEventListener( "load", completed, false );&#xd;
		}&#xd;
	}&#xd;
	return readyList.promise( obj );&#xd;
};&#xd;
&#xd;
// Kick off the DOM ready check even if the user does not&#xd;
jQuery.ready.promise();&#xd;
&#xd;
&#xd;
&#xd;
&#xd;
// Multifunctional method to get and set values of a collection&#xd;
// The value/s can optionally be executed if it's a function&#xd;
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {&#xd;
	var i = 0,&#xd;
		len = elems.length,&#xd;
		bulk = key == null;&#xd;
&#xd;
	// Sets many values&#xd;
	if ( jQuery.type( key ) === "object" ) {&#xd;
		chainable = true;&#xd;
		for ( i in key ) {&#xd;
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );&#xd;
		}&#xd;
&#xd;
	// Sets one value&#xd;
	} else if ( value !== undefined ) {&#xd;
		chainable = true;&#xd;
&#xd;
		if ( !jQuery.isFunction( value ) ) {&#xd;
			raw = true;&#xd;
		}&#xd;
&#xd;
		if ( bulk ) {&#xd;
			// Bulk operations run against the entire set&#xd;
			if ( raw ) {&#xd;
				fn.call( elems, value );&#xd;
				fn = null;&#xd;
&#xd;
			// ...except when executing function values&#xd;
			} else {&#xd;
				bulk = fn;&#xd;
				fn = function( elem, key, value ) {&#xd;
					return bulk.call( jQuery( elem ), value );&#xd;
				};&#xd;
			}&#xd;
		}&#xd;
&#xd;
		if ( fn ) {&#xd;
			for ( ; i &lt; len; i++ ) {&#xd;
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );&#xd;
			}&#xd;
		}&#xd;
	}&#xd;
&#xd;
	return chainable ?&#xd;
		elems :&#xd;
&#xd;
		// Gets&#xd;
		bulk ?&#xd;
			fn.call( elems ) :&#xd;
			len ? fn( elems[0], key ) : emptyGet;&#xd;
};&#xd;
&#xd;
&#xd;
/**&#xd;
 * Determines whether an object can have data&#xd;
 */&#xd;
jQuery.acceptData = function( owner ) {&#xd;
	// Accepts only:&#xd;
	//  - Node&#xd;
	//    - Node.ELEMENT_NODE&#xd;
	//    - Node.DOCUMENT_NODE&#xd;
	//  - Object&#xd;
	//    - Any&#xd;
	/* jshint -W018 */&#xd;
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );&#xd;
};&#xd;
&#xd;
&#xd;
function Data() {&#xd;
	// Support: Android &lt; 4,&#xd;
	// Old WebKit does not have Object.preventExtensions/freeze method,&#xd;
	// return new empty object instead with no [[set]] accessor&#xd;
	Object.defineProperty( this.cache = {}, 0, {&#xd;
		get: function() {&#xd;
			return {};&#xd;
		}&#xd;
	});&#xd;
&#xd;
	this.expando = jQuery.expando + Math.random();&#xd;
}&#xd;
&#xd;
Data.uid = 1;&#xd;
Data.accepts = jQuery.acceptData;&#xd;
&#xd;
Data.prototype = {&#xd;
	key: function( owner ) {&#xd;
		// We can accept data for non-element nodes in modern browsers,&#xd;
		// but we should not, see #8335.&#xd;
		// Always return the key for a frozen object.&#xd;
		if ( !Data.accepts( owner ) ) {&#xd;
			return 0;&#xd;
		}&#xd;
&#xd;
		var descriptor = {},&#xd;
			// Check if the owner object already has a cache key&#xd;
			unlock = owner[ this.expando ];&#xd;
&#xd;
		// If not, create one&#xd;
		if ( !unlock ) {&#xd;
			unlock = Data.uid++;&#xd;
&#xd;
			// Secure it in a non-enumerable, non-writable property&#xd;
			try {&#xd;
				descriptor[ this.expando ] = { value: unlock };&#xd;
				Object.defineProperties( owner, descriptor );&#xd;
&#xd;
			// Support: Android &lt; 4&#xd;
			// Fallback to a less secure definition&#xd;
			} catch ( e ) {&#xd;
				descriptor[ this.expando ] = unlock;&#xd;
				jQuery.extend( owner, descriptor );&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Ensure the cache object&#xd;
		if ( !this.cache[ unlock ] ) {&#xd;
			this.cache[ unlock ] = {};&#xd;
		}&#xd;
&#xd;
		return unlock;&#xd;
	},&#xd;
	set: function( owner, data, value ) {&#xd;
		var prop,&#xd;
			// There may be an unlock assigned to this node,&#xd;
			// if there is no entry for this "owner", create one inline&#xd;
			// and set the unlock as though an owner entry had always existed&#xd;
			unlock = this.key( owner ),&#xd;
			cache = this.cache[ unlock ];&#xd;
&#xd;
		// Handle: [ owner, key, value ] args&#xd;
		if ( typeof data === "string" ) {&#xd;
			cache[ data ] = value;&#xd;
&#xd;
		// Handle: [ owner, { properties } ] args&#xd;
		} else {&#xd;
			// Fresh assignments by object are shallow copied&#xd;
			if ( jQuery.isEmptyObject( cache ) ) {&#xd;
				jQuery.extend( this.cache[ unlock ], data );&#xd;
			// Otherwise, copy the properties one-by-one to the cache object&#xd;
			} else {&#xd;
				for ( prop in data ) {&#xd;
					cache[ prop ] = data[ prop ];&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
		return cache;&#xd;
	},&#xd;
	get: function( owner, key ) {&#xd;
		// Either a valid cache is found, or will be created.&#xd;
		// New caches will be created and the unlock returned,&#xd;
		// allowing direct access to the newly created&#xd;
		// empty data object. A valid owner object must be provided.&#xd;
		var cache = this.cache[ this.key( owner ) ];&#xd;
&#xd;
		return key === undefined ?&#xd;
			cache : cache[ key ];&#xd;
	},&#xd;
	access: function( owner, key, value ) {&#xd;
		var stored;&#xd;
		// In cases where either:&#xd;
		//&#xd;
		//   1. No key was specified&#xd;
		//   2. A string key was specified, but no value provided&#xd;
		//&#xd;
		// Take the "read" path and allow the get method to determine&#xd;
		// which value to return, respectively either:&#xd;
		//&#xd;
		//   1. The entire cache object&#xd;
		//   2. The data stored at the key&#xd;
		//&#xd;
		if ( key === undefined ||&#xd;
				((key &amp;&amp; typeof key === "string") &amp;&amp; value === undefined) ) {&#xd;
&#xd;
			stored = this.get( owner, key );&#xd;
&#xd;
			return stored !== undefined ?&#xd;
				stored : this.get( owner, jQuery.camelCase(key) );&#xd;
		}&#xd;
&#xd;
		// [*]When the key is not a string, or both a key and value&#xd;
		// are specified, set or extend (existing objects) with either:&#xd;
		//&#xd;
		//   1. An object of properties&#xd;
		//   2. A key and value&#xd;
		//&#xd;
		this.set( owner, key, value );&#xd;
&#xd;
		// Since the "set" path can have two possible entry points&#xd;
		// return the expected data based on which path was taken[*]&#xd;
		return value !== undefined ? value : key;&#xd;
	},&#xd;
	remove: function( owner, key ) {&#xd;
		var i, name, camel,&#xd;
			unlock = this.key( owner ),&#xd;
			cache = this.cache[ unlock ];&#xd;
&#xd;
		if ( key === undefined ) {&#xd;
			this.cache[ unlock ] = {};&#xd;
&#xd;
		} else {&#xd;
			// Support array or space separated string of keys&#xd;
			if ( jQuery.isArray( key ) ) {&#xd;
				// If "name" is an array of keys...&#xd;
				// When data is initially created, via ("key", "val") signature,&#xd;
				// keys will be converted to camelCase.&#xd;
				// Since there is no way to tell _how_ a key was added, remove&#xd;
				// both plain key and camelCase key. #12786&#xd;
				// This will only penalize the array argument path.&#xd;
				name = key.concat( key.map( jQuery.camelCase ) );&#xd;
			} else {&#xd;
				camel = jQuery.camelCase( key );&#xd;
				// Try the string as a key before any manipulation&#xd;
				if ( key in cache ) {&#xd;
					name = [ key, camel ];&#xd;
				} else {&#xd;
					// If a key with the spaces exists, use it.&#xd;
					// Otherwise, create an array by matching non-whitespace&#xd;
					name = camel;&#xd;
					name = name in cache ?&#xd;
						[ name ] : ( name.match( rnotwhite ) || [] );&#xd;
				}&#xd;
			}&#xd;
&#xd;
			i = name.length;&#xd;
			while ( i-- ) {&#xd;
				delete cache[ name[ i ] ];&#xd;
			}&#xd;
		}&#xd;
	},&#xd;
	hasData: function( owner ) {&#xd;
		return !jQuery.isEmptyObject(&#xd;
			this.cache[ owner[ this.expando ] ] || {}&#xd;
		);&#xd;
	},&#xd;
	discard: function( owner ) {&#xd;
		if ( owner[ this.expando ] ) {&#xd;
			delete this.cache[ owner[ this.expando ] ];&#xd;
		}&#xd;
	}&#xd;
};&#xd;
var data_priv = new Data();&#xd;
&#xd;
&#xd;
&#xd;
/*&#xd;
	Implementation Summary&#xd;
&#xd;
	1. Enforce API surface and semantic compatibility with 1.9.x branch&#xd;
	2. Improve the module's maintainability by reducing the storage&#xd;
		paths to a single mechanism.&#xd;
	3. Use the same single mechanism to support "private" and "user" data.&#xd;
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)&#xd;
	5. Avoid exposing implementation details on user objects (eg. expando properties)&#xd;
	6. Provide a clear path for implementation upgrade to WeakMap in 2014&#xd;
*/&#xd;
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,&#xd;
	rmultiDash = /([A-Z])/g;&#xd;
&#xd;
function dataAttr( elem, key, data ) {&#xd;
	var name;&#xd;
&#xd;
	// If nothing was found internally, try to fetch any&#xd;
	// data from the HTML5 data-* attribute&#xd;
	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {&#xd;
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();&#xd;
		data = elem.getAttribute( name );&#xd;
&#xd;
		if ( typeof data === "string" ) {&#xd;
			try {&#xd;
				data = data === "true" ? true :&#xd;
					data === "false" ? false :&#xd;
					data === "null" ? null :&#xd;
					// Only convert to a number if it doesn't change the string&#xd;
					+data + "" === data ? +data :&#xd;
					rbrace.test( data ) ? jQuery.parseJSON( data ) :&#xd;
					data;&#xd;
			} catch( e ) {}&#xd;
&#xd;
			// Make sure we set the data so it isn't changed later&#xd;
			data_user.set( elem, key, data );&#xd;
		} else {&#xd;
			data = undefined;&#xd;
		}&#xd;
	}&#xd;
	return data;&#xd;
}&#xd;
&#xd;
jQuery.extend({&#xd;
	hasData: function( elem ) {&#xd;
		return data_user.hasData( elem ) || data_priv.hasData( elem );&#xd;
	},&#xd;
&#xd;
	data: function( elem, name, data ) {&#xd;
		return data_user.access( elem, name, data );&#xd;
	},&#xd;
&#xd;
	removeData: function( elem, name ) {&#xd;
		data_user.remove( elem, name );&#xd;
	},&#xd;
&#xd;
	// TODO: Now that all calls to _data and _removeData have been replaced&#xd;
	// with direct calls to data_priv methods, these can be deprecated.&#xd;
	_data: function( elem, name, data ) {&#xd;
		return data_priv.access( elem, name, data );&#xd;
	},&#xd;
&#xd;
	_removeData: function( elem, name ) {&#xd;
		data_priv.remove( elem, name );&#xd;
	}&#xd;
});&#xd;
&#xd;
jQuery.fn.extend({&#xd;
	data: function( key, value ) {&#xd;
		var i, name, data,&#xd;
			elem = this[ 0 ],&#xd;
			attrs = elem &amp;&amp; elem.attributes;&#xd;
&#xd;
		// Gets all values&#xd;
		if ( key === undefined ) {&#xd;
			if ( this.length ) {&#xd;
				data = data_user.get( elem );&#xd;
&#xd;
				if ( elem.nodeType === 1 &amp;&amp; !data_priv.get( elem, "hasDataAttrs" ) ) {&#xd;
					i = attrs.length;&#xd;
					while ( i-- ) {&#xd;
&#xd;
						// Support: IE11+&#xd;
						// The attrs elements can be null (#14894)&#xd;
						if ( attrs[ i ] ) {&#xd;
							name = attrs[ i ].name;&#xd;
							if ( name.indexOf( "data-" ) === 0 ) {&#xd;
								name = jQuery.camelCase( name.slice(5) );&#xd;
								dataAttr( elem, name, data[ name ] );&#xd;
							}&#xd;
						}&#xd;
					}&#xd;
					data_priv.set( elem, "hasDataAttrs", true );&#xd;
				}&#xd;
			}&#xd;
&#xd;
			return data;&#xd;
		}&#xd;
&#xd;
		// Sets multiple values&#xd;
		if ( typeof key === "object" ) {&#xd;
			return this.each(function() {&#xd;
				data_user.set( this, key );&#xd;
			});&#xd;
		}&#xd;
&#xd;
		return access( this, function( value ) {&#xd;
			var data,&#xd;
				camelKey = jQuery.camelCase( key );&#xd;
&#xd;
			// The calling jQuery object (element matches) is not empty&#xd;
			// (and therefore has an element appears at this[ 0 ]) and the&#xd;
			// `value` parameter was not undefined. An empty jQuery object&#xd;
			// will result in `undefined` for elem = this[ 0 ] which will&#xd;
			// throw an exception if an attempt to read a data cache is made.&#xd;
			if ( elem &amp;&amp; value === undefined ) {&#xd;
				// Attempt to get data from the cache&#xd;
				// with the key as-is&#xd;
				data = data_user.get( elem, key );&#xd;
				if ( data !== undefined ) {&#xd;
					return data;&#xd;
				}&#xd;
&#xd;
				// Attempt to get data from the cache&#xd;
				// with the key camelized&#xd;
				data = data_user.get( elem, camelKey );&#xd;
				if ( data !== undefined ) {&#xd;
					return data;&#xd;
				}&#xd;
&#xd;
				// Attempt to "discover" the data in&#xd;
				// HTML5 custom data-* attrs&#xd;
				data = dataAttr( elem, camelKey, undefined );&#xd;
				if ( data !== undefined ) {&#xd;
					return data;&#xd;
				}&#xd;
&#xd;
				// We tried really hard, but the data doesn't exist.&#xd;
				return;&#xd;
			}&#xd;
&#xd;
			// Set the data...&#xd;
			this.each(function() {&#xd;
				// First, attempt to store a copy or reference of any&#xd;
				// data that might've been store with a camelCased key.&#xd;
				var data = data_user.get( this, camelKey );&#xd;
&#xd;
				// For HTML5 data-* attribute interop, we have to&#xd;
				// store property names with dashes in a camelCase form.&#xd;
				// This might not apply to all properties...*&#xd;
				data_user.set( this, camelKey, value );&#xd;
&#xd;
				// *... In the case of properties that might _actually_&#xd;
				// have dashes, we need to also store a copy of that&#xd;
				// unchanged property.&#xd;
				if ( key.indexOf("-") !== -1 &amp;&amp; data !== undefined ) {&#xd;
					data_user.set( this, key, value );&#xd;
				}&#xd;
			});&#xd;
		}, null, value, arguments.length > 1, null, true );&#xd;
	},&#xd;
&#xd;
	removeData: function( key ) {&#xd;
		return this.each(function() {&#xd;
			data_user.remove( this, key );&#xd;
		});&#xd;
	}&#xd;
});&#xd;
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;&#xd;
&#xd;
var strundefined = typeof undefined;&#xd;
&#xd;
&#xd;
&#xd;
var&#xd;
	rkeyEvent = /^key/,&#xd;
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,&#xd;
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,&#xd;
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;&#xd;
&#xd;
function returnTrue() {&#xd;
	return true;&#xd;
}&#xd;
&#xd;
function returnFalse() {&#xd;
	return false;&#xd;
}&#xd;
&#xd;
function safeActiveElement() {&#xd;
	try {&#xd;
		return document.activeElement;&#xd;
	} catch ( err ) { }&#xd;
}&#xd;
&#xd;
/*&#xd;
 * Helper functions for managing events -- not part of the public interface.&#xd;
 * Props to Dean Edwards' addEvent library for many of the ideas.&#xd;
 */&#xd;
jQuery.event = {&#xd;
&#xd;
	global: {},&#xd;
&#xd;
	add: function( elem, types, handler, data, selector ) {&#xd;
&#xd;
		var handleObjIn, eventHandle, tmp,&#xd;
			events, t, handleObj,&#xd;
			special, handlers, type, namespaces, origType,&#xd;
			elemData = data_priv.get( elem );&#xd;
&#xd;
		// Don't attach events to noData or text/comment nodes (but allow plain objects)&#xd;
		if ( !elemData ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// Caller can pass in an object of custom data in lieu of the handler&#xd;
		if ( handler.handler ) {&#xd;
			handleObjIn = handler;&#xd;
			handler = handleObjIn.handler;&#xd;
			selector = handleObjIn.selector;&#xd;
		}&#xd;
&#xd;
		// Make sure that the handler has a unique ID, used to find/remove it later&#xd;
		if ( !handler.guid ) {&#xd;
			handler.guid = jQuery.guid++;&#xd;
		}&#xd;
&#xd;
		// Init the element's event structure and main handler, if this is the first&#xd;
		if ( !(events = elemData.events) ) {&#xd;
			events = elemData.events = {};&#xd;
		}&#xd;
		if ( !(eventHandle = elemData.handle) ) {&#xd;
			eventHandle = elemData.handle = function( e ) {&#xd;
				// Discard the second event of a jQuery.event.trigger() and&#xd;
				// when an event is called after a page has unloaded&#xd;
				return typeof jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?&#xd;
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;&#xd;
			};&#xd;
		}&#xd;
&#xd;
		// Handle multiple events separated by a space&#xd;
		types = ( types || "" ).match( rnotwhite ) || [ "" ];&#xd;
		t = types.length;&#xd;
		while ( t-- ) {&#xd;
			tmp = rtypenamespace.exec( types[t] ) || [];&#xd;
			type = origType = tmp[1];&#xd;
			namespaces = ( tmp[2] || "" ).split( "." ).sort();&#xd;
&#xd;
			// There *must* be a type, no attaching namespace-only handlers&#xd;
			if ( !type ) {&#xd;
				continue;&#xd;
			}&#xd;
&#xd;
			// If event changes its type, use the special event handlers for the changed type&#xd;
			special = jQuery.event.special[ type ] || {};&#xd;
&#xd;
			// If selector defined, determine special event api type, otherwise given type&#xd;
			type = ( selector ? special.delegateType : special.bindType ) || type;&#xd;
&#xd;
			// Update special based on newly reset type&#xd;
			special = jQuery.event.special[ type ] || {};&#xd;
&#xd;
			// handleObj is passed to all event handlers&#xd;
			handleObj = jQuery.extend({&#xd;
				type: type,&#xd;
				origType: origType,&#xd;
				data: data,&#xd;
				handler: handler,&#xd;
				guid: handler.guid,&#xd;
				selector: selector,&#xd;
				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),&#xd;
				namespace: namespaces.join(".")&#xd;
			}, handleObjIn );&#xd;
&#xd;
			// Init the event handler queue if we're the first&#xd;
			if ( !(handlers = events[ type ]) ) {&#xd;
				handlers = events[ type ] = [];&#xd;
				handlers.delegateCount = 0;&#xd;
&#xd;
				// Only use addEventListener if the special events handler returns false&#xd;
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {&#xd;
					if ( elem.addEventListener ) {&#xd;
						elem.addEventListener( type, eventHandle, false );&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
&#xd;
			if ( special.add ) {&#xd;
				special.add.call( elem, handleObj );&#xd;
&#xd;
				if ( !handleObj.handler.guid ) {&#xd;
					handleObj.handler.guid = handler.guid;&#xd;
				}&#xd;
			}&#xd;
&#xd;
			// Add to the element's handler list, delegates in front&#xd;
			if ( selector ) {&#xd;
				handlers.splice( handlers.delegateCount++, 0, handleObj );&#xd;
			} else {&#xd;
				handlers.push( handleObj );&#xd;
			}&#xd;
&#xd;
			// Keep track of which events have ever been used, for event optimization&#xd;
			jQuery.event.global[ type ] = true;&#xd;
		}&#xd;
&#xd;
	},&#xd;
&#xd;
	// Detach an event or set of events from an element&#xd;
	remove: function( elem, types, handler, selector, mappedTypes ) {&#xd;
&#xd;
		var j, origCount, tmp,&#xd;
			events, t, handleObj,&#xd;
			special, handlers, type, namespaces, origType,&#xd;
			elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );&#xd;
&#xd;
		if ( !elemData || !(events = elemData.events) ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// Once for each type.namespace in types; type may be omitted&#xd;
		types = ( types || "" ).match( rnotwhite ) || [ "" ];&#xd;
		t = types.length;&#xd;
		while ( t-- ) {&#xd;
			tmp = rtypenamespace.exec( types[t] ) || [];&#xd;
			type = origType = tmp[1];&#xd;
			namespaces = ( tmp[2] || "" ).split( "." ).sort();&#xd;
&#xd;
			// Unbind all events (on this namespace, if provided) for the element&#xd;
			if ( !type ) {&#xd;
				for ( type in events ) {&#xd;
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );&#xd;
				}&#xd;
				continue;&#xd;
			}&#xd;
&#xd;
			special = jQuery.event.special[ type ] || {};&#xd;
			type = ( selector ? special.delegateType : special.bindType ) || type;&#xd;
			handlers = events[ type ] || [];&#xd;
			tmp = tmp[2] &amp;&amp; new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );&#xd;
&#xd;
			// Remove matching events&#xd;
			origCount = j = handlers.length;&#xd;
			while ( j-- ) {&#xd;
				handleObj = handlers[ j ];&#xd;
&#xd;
				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;&#xd;
					( !handler || handler.guid === handleObj.guid ) &amp;&amp;&#xd;
					( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;&#xd;
					( !selector || selector === handleObj.selector || selector === "**" &amp;&amp; handleObj.selector ) ) {&#xd;
					handlers.splice( j, 1 );&#xd;
&#xd;
					if ( handleObj.selector ) {&#xd;
						handlers.delegateCount--;&#xd;
					}&#xd;
					if ( special.remove ) {&#xd;
						special.remove.call( elem, handleObj );&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
&#xd;
			// Remove generic event handler if we removed something and no more handlers exist&#xd;
			// (avoids potential for endless recursion during removal of special event handlers)&#xd;
			if ( origCount &amp;&amp; !handlers.length ) {&#xd;
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {&#xd;
					jQuery.removeEvent( elem, type, elemData.handle );&#xd;
				}&#xd;
&#xd;
				delete events[ type ];&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Remove the expando if it's no longer used&#xd;
		if ( jQuery.isEmptyObject( events ) ) {&#xd;
			delete elemData.handle;&#xd;
			data_priv.remove( elem, "events" );&#xd;
		}&#xd;
	},&#xd;
&#xd;
	trigger: function( event, data, elem, onlyHandlers ) {&#xd;
&#xd;
		var i, cur, tmp, bubbleType, ontype, handle, special,&#xd;
			eventPath = [ elem || document ],&#xd;
			type = hasOwn.call( event, "type" ) ? event.type : event,&#xd;
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];&#xd;
&#xd;
		cur = tmp = elem = elem || document;&#xd;
&#xd;
		// Don't do events on text and comment nodes&#xd;
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// focus/blur morphs to focusin/out; ensure we're not firing them right now&#xd;
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		if ( type.indexOf(".") >= 0 ) {&#xd;
			// Namespaced trigger; create a regexp to match event type in handle()&#xd;
			namespaces = type.split(".");&#xd;
			type = namespaces.shift();&#xd;
			namespaces.sort();&#xd;
		}&#xd;
		ontype = type.indexOf(":") &lt; 0 &amp;&amp; "on" + type;&#xd;
&#xd;
		// Caller can pass in a jQuery.Event object, Object, or just an event type string&#xd;
		event = event[ jQuery.expando ] ?&#xd;
			event :&#xd;
			new jQuery.Event( type, typeof event === "object" &amp;&amp; event );&#xd;
&#xd;
		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)&#xd;
		event.isTrigger = onlyHandlers ? 2 : 3;&#xd;
		event.namespace = namespaces.join(".");&#xd;
		event.namespace_re = event.namespace ?&#xd;
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :&#xd;
			null;&#xd;
&#xd;
		// Clean up the event in case it is being reused&#xd;
		event.result = undefined;&#xd;
		if ( !event.target ) {&#xd;
			event.target = elem;&#xd;
		}&#xd;
&#xd;
		// Clone any incoming data and prepend the event, creating the handler arg list&#xd;
		data = data == null ?&#xd;
			[ event ] :&#xd;
			jQuery.makeArray( data, [ event ] );&#xd;
&#xd;
		// Allow special events to draw outside the lines&#xd;
		special = jQuery.event.special[ type ] || {};&#xd;
		if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// Determine event propagation path in advance, per W3C events spec (#9951)&#xd;
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)&#xd;
		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {&#xd;
&#xd;
			bubbleType = special.delegateType || type;&#xd;
			if ( !rfocusMorph.test( bubbleType + type ) ) {&#xd;
				cur = cur.parentNode;&#xd;
			}&#xd;
			for ( ; cur; cur = cur.parentNode ) {&#xd;
				eventPath.push( cur );&#xd;
				tmp = cur;&#xd;
			}&#xd;
&#xd;
			// Only add window if we got to document (e.g., not plain obj or detached DOM)&#xd;
			if ( tmp === (elem.ownerDocument || document) ) {&#xd;
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Fire handlers on the event path&#xd;
		i = 0;&#xd;
		while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {&#xd;
&#xd;
			event.type = i > 1 ?&#xd;
				bubbleType :&#xd;
				special.bindType || type;&#xd;
&#xd;
			// jQuery handler&#xd;
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] &amp;&amp; data_priv.get( cur, "handle" );&#xd;
			if ( handle ) {&#xd;
				handle.apply( cur, data );&#xd;
			}&#xd;
&#xd;
			// Native handler&#xd;
			handle = ontype &amp;&amp; cur[ ontype ];&#xd;
			if ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) {&#xd;
				event.result = handle.apply( cur, data );&#xd;
				if ( event.result === false ) {&#xd;
					event.preventDefault();&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
		event.type = type;&#xd;
&#xd;
		// If nobody prevented the default action, do it now&#xd;
		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {&#xd;
&#xd;
			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp;&#xd;
				jQuery.acceptData( elem ) ) {&#xd;
&#xd;
				// Call a native DOM method on the target with the same name name as the event.&#xd;
				// Don't do default actions on window, that's where global variables be (#6170)&#xd;
				if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {&#xd;
&#xd;
					// Don't re-trigger an onFOO event when we call its FOO() method&#xd;
					tmp = elem[ ontype ];&#xd;
&#xd;
					if ( tmp ) {&#xd;
						elem[ ontype ] = null;&#xd;
					}&#xd;
&#xd;
					// Prevent re-triggering of the same event, since we already bubbled it above&#xd;
					jQuery.event.triggered = type;&#xd;
					elem[ type ]();&#xd;
					jQuery.event.triggered = undefined;&#xd;
&#xd;
					if ( tmp ) {&#xd;
						elem[ ontype ] = tmp;&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		return event.result;&#xd;
	},&#xd;
&#xd;
	dispatch: function( event ) {&#xd;
&#xd;
		// Make a writable jQuery.Event from the native event object&#xd;
		event = jQuery.event.fix( event );&#xd;
&#xd;
		var i, j, ret, matched, handleObj,&#xd;
			handlerQueue = [],&#xd;
			args = slice.call( arguments ),&#xd;
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],&#xd;
			special = jQuery.event.special[ event.type ] || {};&#xd;
&#xd;
		// Use the fix-ed jQuery.Event rather than the (read-only) native event&#xd;
		args[0] = event;&#xd;
		event.delegateTarget = this;&#xd;
&#xd;
		// Call the preDispatch hook for the mapped type, and let it bail if desired&#xd;
		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {&#xd;
			return;&#xd;
		}&#xd;
&#xd;
		// Determine handlers&#xd;
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );&#xd;
&#xd;
		// Run delegates first; they may want to stop propagation beneath us&#xd;
		i = 0;&#xd;
		while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {&#xd;
			event.currentTarget = matched.elem;&#xd;
&#xd;
			j = 0;&#xd;
			while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) {&#xd;
&#xd;
				// Triggered event must either 1) have no namespace, or&#xd;
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).&#xd;
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {&#xd;
&#xd;
					event.handleObj = handleObj;&#xd;
					event.data = handleObj.data;&#xd;
&#xd;
					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )&#xd;
							.apply( matched.elem, args );&#xd;
&#xd;
					if ( ret !== undefined ) {&#xd;
						if ( (event.result = ret) === false ) {&#xd;
							event.preventDefault();&#xd;
							event.stopPropagation();&#xd;
						}&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Call the postDispatch hook for the mapped type&#xd;
		if ( special.postDispatch ) {&#xd;
			special.postDispatch.call( this, event );&#xd;
		}&#xd;
&#xd;
		return event.result;&#xd;
	},&#xd;
&#xd;
	handlers: function( event, handlers ) {&#xd;
		var i, matches, sel, handleObj,&#xd;
			handlerQueue = [],&#xd;
			delegateCount = handlers.delegateCount,&#xd;
			cur = event.target;&#xd;
&#xd;
		// Find delegate handlers&#xd;
		// Black-hole SVG &lt;use> instance trees (#13180)&#xd;
		// Avoid non-left-click bubbling in Firefox (#3861)&#xd;
		if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== "click") ) {&#xd;
&#xd;
			for ( ; cur !== this; cur = cur.parentNode || this ) {&#xd;
&#xd;
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)&#xd;
				if ( cur.disabled !== true || event.type !== "click" ) {&#xd;
					matches = [];&#xd;
					for ( i = 0; i &lt; delegateCount; i++ ) {&#xd;
						handleObj = handlers[ i ];&#xd;
&#xd;
						// Don't conflict with Object.prototype properties (#13203)&#xd;
						sel = handleObj.selector + " ";&#xd;
&#xd;
						if ( matches[ sel ] === undefined ) {&#xd;
							matches[ sel ] = handleObj.needsContext ?&#xd;
								jQuery( sel, this ).index( cur ) >= 0 :&#xd;
								jQuery.find( sel, this, null, [ cur ] ).length;&#xd;
						}&#xd;
						if ( matches[ sel ] ) {&#xd;
							matches.push( handleObj );&#xd;
						}&#xd;
					}&#xd;
					if ( matches.length ) {&#xd;
						handlerQueue.push({ elem: cur, handlers: matches });&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Add the remaining (directly-bound) handlers&#xd;
		if ( delegateCount &lt; handlers.length ) {&#xd;
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });&#xd;
		}&#xd;
&#xd;
		return handlerQueue;&#xd;
	},&#xd;
&#xd;
	// Includes some event props shared by KeyEvent and MouseEvent&#xd;
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),&#xd;
&#xd;
	fixHooks: {},&#xd;
&#xd;
	keyHooks: {&#xd;
		props: "char charCode key keyCode".split(" "),&#xd;
		filter: function( event, original ) {&#xd;
&#xd;
			// Add which for key events&#xd;
			if ( event.which == null ) {&#xd;
				event.which = original.charCode != null ? original.charCode : original.keyCode;&#xd;
			}&#xd;
&#xd;
			return event;&#xd;
		}&#xd;
	},&#xd;
&#xd;
	mouseHooks: {&#xd;
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),&#xd;
		filter: function( event, original ) {&#xd;
			var eventDoc, doc, body,&#xd;
				button = original.button;&#xd;
&#xd;
			// Calculate pageX/Y if missing and clientX/Y available&#xd;
			if ( event.pageX == null &amp;&amp; original.clientX != null ) {&#xd;
				eventDoc = event.target.ownerDocument || document;&#xd;
				doc = eventDoc.documentElement;&#xd;
				body = eventDoc.body;&#xd;
&#xd;
				event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );&#xd;
				event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );&#xd;
			}&#xd;
&#xd;
			// Add which for click: 1 === left; 2 === middle; 3 === right&#xd;
			// Note: button is not normalized, so don't use it&#xd;
			if ( !event.which &amp;&amp; button !== undefined ) {&#xd;
				event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );&#xd;
			}&#xd;
&#xd;
			return event;&#xd;
		}&#xd;
	},&#xd;
&#xd;
	fix: function( event ) {&#xd;
		if ( event[ jQuery.expando ] ) {&#xd;
			return event;&#xd;
		}&#xd;
&#xd;
		// Create a writable copy of the event object and normalize some properties&#xd;
		var i, prop, copy,&#xd;
			type = event.type,&#xd;
			originalEvent = event,&#xd;
			fixHook = this.fixHooks[ type ];&#xd;
&#xd;
		if ( !fixHook ) {&#xd;
			this.fixHooks[ type ] = fixHook =&#xd;
				rmouseEvent.test( type ) ? this.mouseHooks :&#xd;
				rkeyEvent.test( type ) ? this.keyHooks :&#xd;
				{};&#xd;
		}&#xd;
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;&#xd;
&#xd;
		event = new jQuery.Event( originalEvent );&#xd;
&#xd;
		i = copy.length;&#xd;
		while ( i-- ) {&#xd;
			prop = copy[ i ];&#xd;
			event[ prop ] = originalEvent[ prop ];&#xd;
		}&#xd;
&#xd;
		// Support: Cordova 2.5 (WebKit) (#13255)&#xd;
		// All events should have a target; Cordova deviceready doesn't&#xd;
		if ( !event.target ) {&#xd;
			event.target = document;&#xd;
		}&#xd;
&#xd;
		// Support: Safari 6.0+, Chrome &lt; 28&#xd;
		// Target should not be a text node (#504, #13143)&#xd;
		if ( event.target.nodeType === 3 ) {&#xd;
			event.target = event.target.parentNode;&#xd;
		}&#xd;
&#xd;
		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;&#xd;
	},&#xd;
&#xd;
	special: {&#xd;
		load: {&#xd;
			// Prevent triggered image.load events from bubbling to window.load&#xd;
			noBubble: true&#xd;
		},&#xd;
		focus: {&#xd;
			// Fire native event if possible so blur/focus sequence is correct&#xd;
			trigger: function() {&#xd;
				if ( this !== safeActiveElement() &amp;&amp; this.focus ) {&#xd;
					this.focus();&#xd;
					return false;&#xd;
				}&#xd;
			},&#xd;
			delegateType: "focusin"&#xd;
		},&#xd;
		blur: {&#xd;
			trigger: function() {&#xd;
				if ( this === safeActiveElement() &amp;&amp; this.blur ) {&#xd;
					this.blur();&#xd;
					return false;&#xd;
				}&#xd;
			},&#xd;
			delegateType: "focusout"&#xd;
		},&#xd;
		click: {&#xd;
			// For checkbox, fire native event so checked state will be right&#xd;
			trigger: function() {&#xd;
				if ( this.type === "checkbox" &amp;&amp; this.click &amp;&amp; jQuery.nodeName( this, "input" ) ) {&#xd;
					this.click();&#xd;
					return false;&#xd;
				}&#xd;
			},&#xd;
&#xd;
			// For cross-browser consistency, don't fire native .click() on links&#xd;
			_default: function( event ) {&#xd;
				return jQuery.nodeName( event.target, "a" );&#xd;
			}&#xd;
		},&#xd;
&#xd;
		beforeunload: {&#xd;
			postDispatch: function( event ) {&#xd;
&#xd;
				// Support: Firefox 20+&#xd;
				// Firefox doesn't alert if the returnValue field is not set.&#xd;
				if ( event.result !== undefined &amp;&amp; event.originalEvent ) {&#xd;
					event.originalEvent.returnValue = event.result;&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
	},&#xd;
&#xd;
	simulate: function( type, elem, event, bubble ) {&#xd;
		// Piggyback on a donor event to simulate a different one.&#xd;
		// Fake originalEvent to avoid donor's stopPropagation, but if the&#xd;
		// simulated event prevents default then we do the same on the donor.&#xd;
		var e = jQuery.extend(&#xd;
			new jQuery.Event(),&#xd;
			event,&#xd;
			{&#xd;
				type: type,&#xd;
				isSimulated: true,&#xd;
				originalEvent: {}&#xd;
			}&#xd;
		);&#xd;
		if ( bubble ) {&#xd;
			jQuery.event.trigger( e, null, elem );&#xd;
		} else {&#xd;
			jQuery.event.dispatch.call( elem, e );&#xd;
		}&#xd;
		if ( e.isDefaultPrevented() ) {&#xd;
			event.preventDefault();&#xd;
		}&#xd;
	}&#xd;
};&#xd;
&#xd;
jQuery.removeEvent = function( elem, type, handle ) {&#xd;
	if ( elem.removeEventListener ) {&#xd;
		elem.removeEventListener( type, handle, false );&#xd;
	}&#xd;
};&#xd;
&#xd;
jQuery.Event = function( src, props ) {&#xd;
	// Allow instantiation without the 'new' keyword&#xd;
	if ( !(this instanceof jQuery.Event) ) {&#xd;
		return new jQuery.Event( src, props );&#xd;
	}&#xd;
&#xd;
	// Event object&#xd;
	if ( src &amp;&amp; src.type ) {&#xd;
		this.originalEvent = src;&#xd;
		this.type = src.type;&#xd;
&#xd;
		// Events bubbling up the document may have been marked as prevented&#xd;
		// by a handler lower down the tree; reflect the correct value.&#xd;
		this.isDefaultPrevented = src.defaultPrevented ||&#xd;
				src.defaultPrevented === undefined &amp;&amp;&#xd;
				// Support: Android &lt; 4.0&#xd;
				src.returnValue === false ?&#xd;
			returnTrue :&#xd;
			returnFalse;&#xd;
&#xd;
	// Event type&#xd;
	} else {&#xd;
		this.type = src;&#xd;
	}&#xd;
&#xd;
	// Put explicitly provided properties onto the event object&#xd;
	if ( props ) {&#xd;
		jQuery.extend( this, props );&#xd;
	}&#xd;
&#xd;
	// Create a timestamp if incoming event doesn't have one&#xd;
	this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();&#xd;
&#xd;
	// Mark it as fixed&#xd;
	this[ jQuery.expando ] = true;&#xd;
};&#xd;
&#xd;
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding&#xd;
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html&#xd;
jQuery.Event.prototype = {&#xd;
	isDefaultPrevented: returnFalse,&#xd;
	isPropagationStopped: returnFalse,&#xd;
	isImmediatePropagationStopped: returnFalse,&#xd;
&#xd;
	preventDefault: function() {&#xd;
		var e = this.originalEvent;&#xd;
&#xd;
		this.isDefaultPrevented = returnTrue;&#xd;
&#xd;
		if ( e &amp;&amp; e.preventDefault ) {&#xd;
			e.preventDefault();&#xd;
		}&#xd;
	},&#xd;
	stopPropagation: function() {&#xd;
		var e = this.originalEvent;&#xd;
&#xd;
		this.isPropagationStopped = returnTrue;&#xd;
&#xd;
		if ( e &amp;&amp; e.stopPropagation ) {&#xd;
			e.stopPropagation();&#xd;
		}&#xd;
	},&#xd;
	stopImmediatePropagation: function() {&#xd;
		var e = this.originalEvent;&#xd;
&#xd;
		this.isImmediatePropagationStopped = returnTrue;&#xd;
&#xd;
		if ( e &amp;&amp; e.stopImmediatePropagation ) {&#xd;
			e.stopImmediatePropagation();&#xd;
		}&#xd;
&#xd;
		this.stopPropagation();&#xd;
	}&#xd;
};&#xd;
&#xd;
// Create mouseenter/leave events using mouseover/out and event-time checks&#xd;
// Support: Chrome 15+&#xd;
jQuery.each({&#xd;
	mouseenter: "mouseover",&#xd;
	mouseleave: "mouseout",&#xd;
	pointerenter: "pointerover",&#xd;
	pointerleave: "pointerout"&#xd;
}, function( orig, fix ) {&#xd;
	jQuery.event.special[ orig ] = {&#xd;
		delegateType: fix,&#xd;
		bindType: fix,&#xd;
&#xd;
		handle: function( event ) {&#xd;
			var ret,&#xd;
				target = this,&#xd;
				related = event.relatedTarget,&#xd;
				handleObj = event.handleObj;&#xd;
&#xd;
			// For mousenter/leave call the handler if related is outside the target.&#xd;
			// NB: No relatedTarget if the mouse left/entered the browser window&#xd;
			if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {&#xd;
				event.type = handleObj.origType;&#xd;
				ret = handleObj.handler.apply( this, arguments );&#xd;
				event.type = fix;&#xd;
			}&#xd;
			return ret;&#xd;
		}&#xd;
	};&#xd;
});&#xd;
&#xd;
// Create "bubbling" focus and blur events&#xd;
// Support: Firefox, Chrome, Safari&#xd;
if ( !support.focusinBubbles ) {&#xd;
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {&#xd;
&#xd;
		// Attach a single capturing handler on the document while someone wants focusin/focusout&#xd;
		var handler = function( event ) {&#xd;
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );&#xd;
			};&#xd;
&#xd;
		jQuery.event.special[ fix ] = {&#xd;
			setup: function() {&#xd;
				var doc = this.ownerDocument || this,&#xd;
					attaches = data_priv.access( doc, fix );&#xd;
&#xd;
				if ( !attaches ) {&#xd;
					doc.addEventListener( orig, handler, true );&#xd;
				}&#xd;
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );&#xd;
			},&#xd;
			teardown: function() {&#xd;
				var doc = this.ownerDocument || this,&#xd;
					attaches = data_priv.access( doc, fix ) - 1;&#xd;
&#xd;
				if ( !attaches ) {&#xd;
					doc.removeEventListener( orig, handler, true );&#xd;
					data_priv.remove( doc, fix );&#xd;
&#xd;
				} else {&#xd;
					data_priv.access( doc, fix, attaches );&#xd;
				}&#xd;
			}&#xd;
		};&#xd;
	});&#xd;
}&#xd;
&#xd;
jQuery.fn.extend({&#xd;
&#xd;
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {&#xd;
		var origFn, type;&#xd;
&#xd;
		// Types can be a map of types/handlers&#xd;
		if ( typeof types === "object" ) {&#xd;
			// ( types-Object, selector, data )&#xd;
			if ( typeof selector !== "string" ) {&#xd;
				// ( types-Object, data )&#xd;
				data = data || selector;&#xd;
				selector = undefined;&#xd;
			}&#xd;
			for ( type in types ) {&#xd;
				this.on( type, selector, data, types[ type ], one );&#xd;
			}&#xd;
			return this;&#xd;
		}&#xd;
&#xd;
		if ( data == null &amp;&amp; fn == null ) {&#xd;
			// ( types, fn )&#xd;
			fn = selector;&#xd;
			data = selector = undefined;&#xd;
		} else if ( fn == null ) {&#xd;
			if ( typeof selector === "string" ) {&#xd;
				// ( types, selector, fn )&#xd;
				fn = data;&#xd;
				data = undefined;&#xd;
			} else {&#xd;
				// ( types, data, fn )&#xd;
				fn = data;&#xd;
				data = selector;&#xd;
				selector = undefined;&#xd;
			}&#xd;
		}&#xd;
		if ( fn === false ) {&#xd;
			fn = returnFalse;&#xd;
		} else if ( !fn ) {&#xd;
			return this;&#xd;
		}&#xd;
&#xd;
		if ( one === 1 ) {&#xd;
			origFn = fn;&#xd;
			fn = function( event ) {&#xd;
				// Can use an empty set, since event contains the info&#xd;
				jQuery().off( event );&#xd;
				return origFn.apply( this, arguments );&#xd;
			};&#xd;
			// Use same guid so caller can remove using origFn&#xd;
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );&#xd;
		}&#xd;
		return this.each( function() {&#xd;
			jQuery.event.add( this, types, fn, data, selector );&#xd;
		});&#xd;
	},&#xd;
	one: function( types, selector, data, fn ) {&#xd;
		return this.on( types, selector, data, fn, 1 );&#xd;
	},&#xd;
	off: function( types, selector, fn ) {&#xd;
		var handleObj, type;&#xd;
		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {&#xd;
			// ( event )  dispatched jQuery.Event&#xd;
			handleObj = types.handleObj;&#xd;
			jQuery( types.delegateTarget ).off(&#xd;
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,&#xd;
				handleObj.selector,&#xd;
				handleObj.handler&#xd;
			);&#xd;
			return this;&#xd;
		}&#xd;
		if ( typeof types === "object" ) {&#xd;
			// ( types-object [, selector] )&#xd;
			for ( type in types ) {&#xd;
				this.off( type, selector, types[ type ] );&#xd;
			}&#xd;
			return this;&#xd;
		}&#xd;
		if ( selector === false || typeof selector === "function" ) {&#xd;
			// ( types [, fn] )&#xd;
			fn = selector;&#xd;
			selector = undefined;&#xd;
		}&#xd;
		if ( fn === false ) {&#xd;
			fn = returnFalse;&#xd;
		}&#xd;
		return this.each(function() {&#xd;
			jQuery.event.remove( this, types, fn, selector );&#xd;
		});&#xd;
	},&#xd;
&#xd;
	trigger: function( type, data ) {&#xd;
		return this.each(function() {&#xd;
			jQuery.event.trigger( type, data, this );&#xd;
		});&#xd;
	},&#xd;
	triggerHandler: function( type, data ) {&#xd;
		var elem = this[0];&#xd;
		if ( elem ) {&#xd;
			return jQuery.event.trigger( type, data, elem, true );&#xd;
		}&#xd;
	}&#xd;
});&#xd;
var nonce = jQuery.now();&#xd;
&#xd;
var rquery = (/\?/);&#xd;
&#xd;
&#xd;
&#xd;
// Support: Android 2.3&#xd;
// Workaround failure to string-cast null input&#xd;
jQuery.parseJSON = function( data ) {&#xd;
	return JSON.parse( data + "" );&#xd;
};&#xd;
&#xd;
&#xd;
// Cross-browser xml parsing&#xd;
jQuery.parseXML = function( data ) {&#xd;
	var xml, tmp;&#xd;
	if ( !data || typeof data !== "string" ) {&#xd;
		return null;&#xd;
	}&#xd;
&#xd;
	// Support: IE9&#xd;
	try {&#xd;
		tmp = new DOMParser();&#xd;
		xml = tmp.parseFromString( data, "text/xml" );&#xd;
	} catch ( e ) {&#xd;
		xml = undefined;&#xd;
	}&#xd;
&#xd;
	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {&#xd;
		jQuery.error( "Invalid XML: " + data );&#xd;
	}&#xd;
	return xml;&#xd;
};&#xd;
&#xd;
&#xd;
var&#xd;
	// Document location&#xd;
	ajaxLocParts,&#xd;
	ajaxLocation,&#xd;
&#xd;
	rhash = /#.*$/,&#xd;
	rts = /([?&amp;])_=[^&amp;]*/,&#xd;
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,&#xd;
	// #7653, #8125, #8152: local protocol detection&#xd;
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,&#xd;
	rnoContent = /^(?:GET|HEAD)$/,&#xd;
	rprotocol = /^\/\//,&#xd;
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,&#xd;
&#xd;
	/* Prefilters&#xd;
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)&#xd;
	 * 2) These are called:&#xd;
	 *    - BEFORE asking for a transport&#xd;
	 *    - AFTER param serialization (s.data is a string if s.processData is true)&#xd;
	 * 3) key is the dataType&#xd;
	 * 4) the catchall symbol "*" can be used&#xd;
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed&#xd;
	 */&#xd;
	prefilters = {},&#xd;
&#xd;
	/* Transports bindings&#xd;
	 * 1) key is the dataType&#xd;
	 * 2) the catchall symbol "*" can be used&#xd;
	 * 3) selection will start with transport dataType and THEN go to "*" if needed&#xd;
	 */&#xd;
	transports = {},&#xd;
&#xd;
	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression&#xd;
	allTypes = "*/".concat("*");&#xd;
&#xd;
// #8138, IE may throw an exception when accessing&#xd;
// a field from window.location if document.domain has been set&#xd;
try {&#xd;
	ajaxLocation = location.href;&#xd;
} catch( e ) {&#xd;
	// Use the href attribute of an A element&#xd;
	// since IE will modify it given document.location&#xd;
	ajaxLocation = document.createElement( "a" );&#xd;
	ajaxLocation.href = "";&#xd;
	ajaxLocation = ajaxLocation.href;&#xd;
}&#xd;
&#xd;
// Segment location into parts&#xd;
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];&#xd;
&#xd;
// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport&#xd;
function addToPrefiltersOrTransports( structure ) {&#xd;
&#xd;
	// dataTypeExpression is optional and defaults to "*"&#xd;
	return function( dataTypeExpression, func ) {&#xd;
&#xd;
		if ( typeof dataTypeExpression !== "string" ) {&#xd;
			func = dataTypeExpression;&#xd;
			dataTypeExpression = "*";&#xd;
		}&#xd;
&#xd;
		var dataType,&#xd;
			i = 0,&#xd;
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];&#xd;
&#xd;
		if ( jQuery.isFunction( func ) ) {&#xd;
			// For each dataType in the dataTypeExpression&#xd;
			while ( (dataType = dataTypes[i++]) ) {&#xd;
				// Prepend if requested&#xd;
				if ( dataType[0] === "+" ) {&#xd;
					dataType = dataType.slice( 1 ) || "*";&#xd;
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );&#xd;
&#xd;
				// Otherwise append&#xd;
				} else {&#xd;
					(structure[ dataType ] = structure[ dataType ] || []).push( func );&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
	};&#xd;
}&#xd;
&#xd;
// Base inspection function for prefilters and transports&#xd;
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {&#xd;
&#xd;
	var inspected = {},&#xd;
		seekingTransport = ( structure === transports );&#xd;
&#xd;
	function inspect( dataType ) {&#xd;
		var selected;&#xd;
		inspected[ dataType ] = true;&#xd;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {&#xd;
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );&#xd;
			if ( typeof dataTypeOrTransport === "string" &amp;&amp; !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {&#xd;
				options.dataTypes.unshift( dataTypeOrTransport );&#xd;
				inspect( dataTypeOrTransport );&#xd;
				return false;&#xd;
			} else if ( seekingTransport ) {&#xd;
				return !( selected = dataTypeOrTransport );&#xd;
			}&#xd;
		});&#xd;
		return selected;&#xd;
	}&#xd;
&#xd;
	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] &amp;&amp; inspect( "*" );&#xd;
}&#xd;
&#xd;
// A special extend for ajax options&#xd;
// that takes "flat" options (not to be deep extended)&#xd;
// Fixes #9887&#xd;
function ajaxExtend( target, src ) {&#xd;
	var key, deep,&#xd;
		flatOptions = jQuery.ajaxSettings.flatOptions || {};&#xd;
&#xd;
	for ( key in src ) {&#xd;
		if ( src[ key ] !== undefined ) {&#xd;
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];&#xd;
		}&#xd;
	}&#xd;
	if ( deep ) {&#xd;
		jQuery.extend( true, target, deep );&#xd;
	}&#xd;
&#xd;
	return target;&#xd;
}&#xd;
&#xd;
/* Handles responses to an ajax request:&#xd;
 * - finds the right dataType (mediates between content-type and expected dataType)&#xd;
 * - returns the corresponding response&#xd;
 */&#xd;
function ajaxHandleResponses( s, jqXHR, responses ) {&#xd;
&#xd;
	var ct, type, finalDataType, firstDataType,&#xd;
		contents = s.contents,&#xd;
		dataTypes = s.dataTypes;&#xd;
&#xd;
	// Remove auto dataType and get content-type in the process&#xd;
	while ( dataTypes[ 0 ] === "*" ) {&#xd;
		dataTypes.shift();&#xd;
		if ( ct === undefined ) {&#xd;
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");&#xd;
		}&#xd;
	}&#xd;
&#xd;
	// Check if we're dealing with a known content-type&#xd;
	if ( ct ) {&#xd;
		for ( type in contents ) {&#xd;
			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {&#xd;
				dataTypes.unshift( type );&#xd;
				break;&#xd;
			}&#xd;
		}&#xd;
	}&#xd;
&#xd;
	// Check to see if we have a response for the expected dataType&#xd;
	if ( dataTypes[ 0 ] in responses ) {&#xd;
		finalDataType = dataTypes[ 0 ];&#xd;
	} else {&#xd;
		// Try convertible dataTypes&#xd;
		for ( type in responses ) {&#xd;
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {&#xd;
				finalDataType = type;&#xd;
				break;&#xd;
			}&#xd;
			if ( !firstDataType ) {&#xd;
				firstDataType = type;&#xd;
			}&#xd;
		}&#xd;
		// Or just use first one&#xd;
		finalDataType = finalDataType || firstDataType;&#xd;
	}&#xd;
&#xd;
	// If we found a dataType&#xd;
	// We add the dataType to the list if needed&#xd;
	// and return the corresponding response&#xd;
	if ( finalDataType ) {&#xd;
		if ( finalDataType !== dataTypes[ 0 ] ) {&#xd;
			dataTypes.unshift( finalDataType );&#xd;
		}&#xd;
		return responses[ finalDataType ];&#xd;
	}&#xd;
}&#xd;
&#xd;
/* Chain conversions given the request and the original response&#xd;
 * Also sets the responseXXX fields on the jqXHR instance&#xd;
 */&#xd;
function ajaxConvert( s, response, jqXHR, isSuccess ) {&#xd;
	var conv2, current, conv, tmp, prev,&#xd;
		converters = {},&#xd;
		// Work with a copy of dataTypes in case we need to modify it for conversion&#xd;
		dataTypes = s.dataTypes.slice();&#xd;
&#xd;
	// Create converters map with lowercased keys&#xd;
	if ( dataTypes[ 1 ] ) {&#xd;
		for ( conv in s.converters ) {&#xd;
			converters[ conv.toLowerCase() ] = s.converters[ conv ];&#xd;
		}&#xd;
	}&#xd;
&#xd;
	current = dataTypes.shift();&#xd;
&#xd;
	// Convert to each sequential dataType&#xd;
	while ( current ) {&#xd;
&#xd;
		if ( s.responseFields[ current ] ) {&#xd;
			jqXHR[ s.responseFields[ current ] ] = response;&#xd;
		}&#xd;
&#xd;
		// Apply the dataFilter if provided&#xd;
		if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {&#xd;
			response = s.dataFilter( response, s.dataType );&#xd;
		}&#xd;
&#xd;
		prev = current;&#xd;
		current = dataTypes.shift();&#xd;
&#xd;
		if ( current ) {&#xd;
&#xd;
		// There's only work to do if current dataType is non-auto&#xd;
			if ( current === "*" ) {&#xd;
&#xd;
				current = prev;&#xd;
&#xd;
			// Convert response if prev dataType is non-auto and differs from current&#xd;
			} else if ( prev !== "*" &amp;&amp; prev !== current ) {&#xd;
&#xd;
				// Seek a direct converter&#xd;
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];&#xd;
&#xd;
				// If none found, seek a pair&#xd;
				if ( !conv ) {&#xd;
					for ( conv2 in converters ) {&#xd;
&#xd;
						// If conv2 outputs current&#xd;
						tmp = conv2.split( " " );&#xd;
						if ( tmp[ 1 ] === current ) {&#xd;
&#xd;
							// If prev can be converted to accepted input&#xd;
							conv = converters[ prev + " " + tmp[ 0 ] ] ||&#xd;
								converters[ "* " + tmp[ 0 ] ];&#xd;
							if ( conv ) {&#xd;
								// Condense equivalence converters&#xd;
								if ( conv === true ) {&#xd;
									conv = converters[ conv2 ];&#xd;
&#xd;
								// Otherwise, insert the intermediate dataType&#xd;
								} else if ( converters[ conv2 ] !== true ) {&#xd;
									current = tmp[ 0 ];&#xd;
									dataTypes.unshift( tmp[ 1 ] );&#xd;
								}&#xd;
								break;&#xd;
							}&#xd;
						}&#xd;
					}&#xd;
				}&#xd;
&#xd;
				// Apply converter (if not an equivalence)&#xd;
				if ( conv !== true ) {&#xd;
&#xd;
					// Unless errors are allowed to bubble, catch and return them&#xd;
					if ( conv &amp;&amp; s[ "throws" ] ) {&#xd;
						response = conv( response );&#xd;
					} else {&#xd;
						try {&#xd;
							response = conv( response );&#xd;
						} catch ( e ) {&#xd;
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };&#xd;
						}&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
	}&#xd;
&#xd;
	return { state: "success", data: response };&#xd;
}&#xd;
&#xd;
jQuery.extend({&#xd;
&#xd;
	// Counter for holding the number of active queries&#xd;
	active: 0,&#xd;
&#xd;
	// Last-Modified header cache for next request&#xd;
	lastModified: {},&#xd;
	etag: {},&#xd;
&#xd;
	ajaxSettings: {&#xd;
		url: ajaxLocation,&#xd;
		type: "GET",&#xd;
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),&#xd;
		global: true,&#xd;
		processData: true,&#xd;
		async: true,&#xd;
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",&#xd;
		/*&#xd;
		timeout: 0,&#xd;
		data: null,&#xd;
		dataType: null,&#xd;
		username: null,&#xd;
		password: null,&#xd;
		cache: null,&#xd;
		throws: false,&#xd;
		traditional: false,&#xd;
		headers: {},&#xd;
		*/&#xd;
&#xd;
		accepts: {&#xd;
			"*": allTypes,&#xd;
			text: "text/plain",&#xd;
			html: "text/html",&#xd;
			xml: "application/xml, text/xml",&#xd;
			json: "application/json, text/javascript"&#xd;
		},&#xd;
&#xd;
		contents: {&#xd;
			xml: /xml/,&#xd;
			html: /html/,&#xd;
			json: /json/&#xd;
		},&#xd;
&#xd;
		responseFields: {&#xd;
			xml: "responseXML",&#xd;
			text: "responseText",&#xd;
			json: "responseJSON"&#xd;
		},&#xd;
&#xd;
		// Data converters&#xd;
		// Keys separate source (or catchall "*") and destination types with a single space&#xd;
		converters: {&#xd;
&#xd;
			// Convert anything to text&#xd;
			"* text": String,&#xd;
&#xd;
			// Text to html (true = no transformation)&#xd;
			"text html": true,&#xd;
&#xd;
			// Evaluate text as a json expression&#xd;
			"text json": jQuery.parseJSON,&#xd;
&#xd;
			// Parse text as xml&#xd;
			"text xml": jQuery.parseXML&#xd;
		},&#xd;
&#xd;
		// For options that shouldn't be deep extended:&#xd;
		// you can add your own custom options here if&#xd;
		// and when you create one that shouldn't be&#xd;
		// deep extended (see ajaxExtend)&#xd;
		flatOptions: {&#xd;
			url: true,&#xd;
			context: true&#xd;
		}&#xd;
	},&#xd;
&#xd;
	// Creates a full fledged settings object into target&#xd;
	// with both ajaxSettings and settings fields.&#xd;
	// If target is omitted, writes into ajaxSettings.&#xd;
	ajaxSetup: function( target, settings ) {&#xd;
		return settings ?&#xd;
&#xd;
			// Building a settings object&#xd;
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :&#xd;
&#xd;
			// Extending ajaxSettings&#xd;
			ajaxExtend( jQuery.ajaxSettings, target );&#xd;
	},&#xd;
&#xd;
	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),&#xd;
	ajaxTransport: addToPrefiltersOrTransports( transports ),&#xd;
&#xd;
	// Main method&#xd;
	ajax: function( url, options ) {&#xd;
&#xd;
		// If url is an object, simulate pre-1.5 signature&#xd;
		if ( typeof url === "object" ) {&#xd;
			options = url;&#xd;
			url = undefined;&#xd;
		}&#xd;
&#xd;
		// Force options to be an object&#xd;
		options = options || {};&#xd;
&#xd;
		var transport,&#xd;
			// URL without anti-cache param&#xd;
			cacheURL,&#xd;
			// Response headers&#xd;
			responseHeadersString,&#xd;
			responseHeaders,&#xd;
			// timeout handle&#xd;
			timeoutTimer,&#xd;
			// Cross-domain detection vars&#xd;
			parts,&#xd;
			// To know if global events are to be dispatched&#xd;
			fireGlobals,&#xd;
			// Loop variable&#xd;
			i,&#xd;
			// Create the final options object&#xd;
			s = jQuery.ajaxSetup( {}, options ),&#xd;
			// Callbacks context&#xd;
			callbackContext = s.context || s,&#xd;
			// Context for global events is callbackContext if it is a DOM node or jQuery collection&#xd;
			globalEventContext = s.context &amp;&amp; ( callbackContext.nodeType || callbackContext.jquery ) ?&#xd;
				jQuery( callbackContext ) :&#xd;
				jQuery.event,&#xd;
			// Deferreds&#xd;
			deferred = jQuery.Deferred(),&#xd;
			completeDeferred = jQuery.Callbacks("once memory"),&#xd;
			// Status-dependent callbacks&#xd;
			statusCode = s.statusCode || {},&#xd;
			// Headers (they are sent all at once)&#xd;
			requestHeaders = {},&#xd;
			requestHeadersNames = {},&#xd;
			// The jqXHR state&#xd;
			state = 0,&#xd;
			// Default abort message&#xd;
			strAbort = "canceled",&#xd;
			// Fake xhr&#xd;
			jqXHR = {&#xd;
				readyState: 0,&#xd;
&#xd;
				// Builds headers hashtable if needed&#xd;
				getResponseHeader: function( key ) {&#xd;
					var match;&#xd;
					if ( state === 2 ) {&#xd;
						if ( !responseHeaders ) {&#xd;
							responseHeaders = {};&#xd;
							while ( (match = rheaders.exec( responseHeadersString )) ) {&#xd;
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];&#xd;
							}&#xd;
						}&#xd;
						match = responseHeaders[ key.toLowerCase() ];&#xd;
					}&#xd;
					return match == null ? null : match;&#xd;
				},&#xd;
&#xd;
				// Raw string&#xd;
				getAllResponseHeaders: function() {&#xd;
					return state === 2 ? responseHeadersString : null;&#xd;
				},&#xd;
&#xd;
				// Caches the header&#xd;
				setRequestHeader: function( name, value ) {&#xd;
					var lname = name.toLowerCase();&#xd;
					if ( !state ) {&#xd;
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;&#xd;
						requestHeaders[ name ] = value;&#xd;
					}&#xd;
					return this;&#xd;
				},&#xd;
&#xd;
				// Overrides response content-type header&#xd;
				overrideMimeType: function( type ) {&#xd;
					if ( !state ) {&#xd;
						s.mimeType = type;&#xd;
					}&#xd;
					return this;&#xd;
				},&#xd;
&#xd;
				// Status-dependent callbacks&#xd;
				statusCode: function( map ) {&#xd;
					var code;&#xd;
					if ( map ) {&#xd;
						if ( state &lt; 2 ) {&#xd;
							for ( code in map ) {&#xd;
								// Lazy-add the new callback in a way that preserves old ones&#xd;
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];&#xd;
							}&#xd;
						} else {&#xd;
							// Execute the appropriate callbacks&#xd;
							jqXHR.always( map[ jqXHR.status ] );&#xd;
						}&#xd;
					}&#xd;
					return this;&#xd;
				},&#xd;
&#xd;
				// Cancel the request&#xd;
				abort: function( statusText ) {&#xd;
					var finalText = statusText || strAbort;&#xd;
					if ( transport ) {&#xd;
						transport.abort( finalText );&#xd;
					}&#xd;
					done( 0, finalText );&#xd;
					return this;&#xd;
				}&#xd;
			};&#xd;
&#xd;
		// Attach deferreds&#xd;
		deferred.promise( jqXHR ).complete = completeDeferred.add;&#xd;
		jqXHR.success = jqXHR.done;&#xd;
		jqXHR.error = jqXHR.fail;&#xd;
&#xd;
		// Remove hash character (#7531: and string promotion)&#xd;
		// Add protocol if not provided (prefilters might expect it)&#xd;
		// Handle falsy url in the settings object (#10093: consistency with old signature)&#xd;
		// We also use the url parameter if available&#xd;
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )&#xd;
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );&#xd;
&#xd;
		// Alias method option to type as per ticket #12004&#xd;
		s.type = options.method || options.type || s.method || s.type;&#xd;
&#xd;
		// Extract dataTypes list&#xd;
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];&#xd;
&#xd;
		// A cross-domain request is in order when we have a protocol:host:port mismatch&#xd;
		if ( s.crossDomain == null ) {&#xd;
			parts = rurl.exec( s.url.toLowerCase() );&#xd;
			s.crossDomain = !!( parts &amp;&amp;&#xd;
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||&#xd;
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==&#xd;
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )&#xd;
			);&#xd;
		}&#xd;
&#xd;
		// Convert data if not already a string&#xd;
		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== "string" ) {&#xd;
			s.data = jQuery.param( s.data, s.traditional );&#xd;
		}&#xd;
&#xd;
		// Apply prefilters&#xd;
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );&#xd;
&#xd;
		// If request was aborted inside a prefilter, stop there&#xd;
		if ( state === 2 ) {&#xd;
			return jqXHR;&#xd;
		}&#xd;
&#xd;
		// We can fire global events as of now if asked to&#xd;
		fireGlobals = s.global;&#xd;
&#xd;
		// Watch for a new set of requests&#xd;
		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {&#xd;
			jQuery.event.trigger("ajaxStart");&#xd;
		}&#xd;
&#xd;
		// Uppercase the type&#xd;
		s.type = s.type.toUpperCase();&#xd;
&#xd;
		// Determine if request has content&#xd;
		s.hasContent = !rnoContent.test( s.type );&#xd;
&#xd;
		// Save the URL in case we're toying with the If-Modified-Since&#xd;
		// and/or If-None-Match header later on&#xd;
		cacheURL = s.url;&#xd;
&#xd;
		// More options handling for requests with no content&#xd;
		if ( !s.hasContent ) {&#xd;
&#xd;
			// If data is available, append data to url&#xd;
			if ( s.data ) {&#xd;
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&amp;" : "?" ) + s.data );&#xd;
				// #9682: remove data so that it's not used in an eventual retry&#xd;
				delete s.data;&#xd;
			}&#xd;
&#xd;
			// Add anti-cache in url if needed&#xd;
			if ( s.cache === false ) {&#xd;
				s.url = rts.test( cacheURL ) ?&#xd;
&#xd;
					// If there is already a '_' parameter, set its value&#xd;
					cacheURL.replace( rts, "$1_=" + nonce++ ) :&#xd;
&#xd;
					// Otherwise add one to the end&#xd;
					cacheURL + ( rquery.test( cacheURL ) ? "&amp;" : "?" ) + "_=" + nonce++;&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.&#xd;
		if ( s.ifModified ) {&#xd;
			if ( jQuery.lastModified[ cacheURL ] ) {&#xd;
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );&#xd;
			}&#xd;
			if ( jQuery.etag[ cacheURL ] ) {&#xd;
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Set the correct header, if data is being sent&#xd;
		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {&#xd;
			jqXHR.setRequestHeader( "Content-Type", s.contentType );&#xd;
		}&#xd;
&#xd;
		// Set the Accepts header for the server, depending on the dataType&#xd;
		jqXHR.setRequestHeader(&#xd;
			"Accept",&#xd;
			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?&#xd;
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :&#xd;
				s.accepts[ "*" ]&#xd;
		);&#xd;
&#xd;
		// Check for headers option&#xd;
		for ( i in s.headers ) {&#xd;
			jqXHR.setRequestHeader( i, s.headers[ i ] );&#xd;
		}&#xd;
&#xd;
		// Allow custom headers/mimetypes and early abort&#xd;
		if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {&#xd;
			// Abort if not done already and return&#xd;
			return jqXHR.abort();&#xd;
		}&#xd;
&#xd;
		// aborting is no longer a cancellation&#xd;
		strAbort = "abort";&#xd;
&#xd;
		// Install callbacks on deferreds&#xd;
		for ( i in { success: 1, error: 1, complete: 1 } ) {&#xd;
			jqXHR[ i ]( s[ i ] );&#xd;
		}&#xd;
&#xd;
		// Get transport&#xd;
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );&#xd;
&#xd;
		// If no transport, we auto-abort&#xd;
		if ( !transport ) {&#xd;
			done( -1, "No Transport" );&#xd;
		} else {&#xd;
			jqXHR.readyState = 1;&#xd;
&#xd;
			// Send global event&#xd;
			if ( fireGlobals ) {&#xd;
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );&#xd;
			}&#xd;
			// Timeout&#xd;
			if ( s.async &amp;&amp; s.timeout > 0 ) {&#xd;
				timeoutTimer = setTimeout(function() {&#xd;
					jqXHR.abort("timeout");&#xd;
				}, s.timeout );&#xd;
			}&#xd;
&#xd;
			try {&#xd;
				state = 1;&#xd;
				transport.send( requestHeaders, done );&#xd;
			} catch ( e ) {&#xd;
				// Propagate exception as error if not done&#xd;
				if ( state &lt; 2 ) {&#xd;
					done( -1, e );&#xd;
				// Simply rethrow otherwise&#xd;
				} else {&#xd;
					throw e;&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		// Callback for when everything is done&#xd;
		function done( status, nativeStatusText, responses, headers ) {&#xd;
			var isSuccess, success, error, response, modified,&#xd;
				statusText = nativeStatusText;&#xd;
&#xd;
			// Called once&#xd;
			if ( state === 2 ) {&#xd;
				return;&#xd;
			}&#xd;
&#xd;
			// State is "done" now&#xd;
			state = 2;&#xd;
&#xd;
			// Clear timeout if it exists&#xd;
			if ( timeoutTimer ) {&#xd;
				clearTimeout( timeoutTimer );&#xd;
			}&#xd;
&#xd;
			// Dereference transport for early garbage collection&#xd;
			// (no matter how long the jqXHR object will be used)&#xd;
			transport = undefined;&#xd;
&#xd;
			// Cache response headers&#xd;
			responseHeadersString = headers || "";&#xd;
&#xd;
			// Set readyState&#xd;
			jqXHR.readyState = status > 0 ? 4 : 0;&#xd;
&#xd;
			// Determine if successful&#xd;
			isSuccess = status >= 200 &amp;&amp; status &lt; 300 || status === 304;&#xd;
&#xd;
			// Get response data&#xd;
			if ( responses ) {&#xd;
				response = ajaxHandleResponses( s, jqXHR, responses );&#xd;
			}&#xd;
&#xd;
			// Convert no matter what (that way responseXXX fields are always set)&#xd;
			response = ajaxConvert( s, response, jqXHR, isSuccess );&#xd;
&#xd;
			// If successful, handle type chaining&#xd;
			if ( isSuccess ) {&#xd;
&#xd;
				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.&#xd;
				if ( s.ifModified ) {&#xd;
					modified = jqXHR.getResponseHeader("Last-Modified");&#xd;
					if ( modified ) {&#xd;
						jQuery.lastModified[ cacheURL ] = modified;&#xd;
					}&#xd;
					modified = jqXHR.getResponseHeader("etag");&#xd;
					if ( modified ) {&#xd;
						jQuery.etag[ cacheURL ] = modified;&#xd;
					}&#xd;
				}&#xd;
&#xd;
				// if no content&#xd;
				if ( status === 204 || s.type === "HEAD" ) {&#xd;
					statusText = "nocontent";&#xd;
&#xd;
				// if not modified&#xd;
				} else if ( status === 304 ) {&#xd;
					statusText = "notmodified";&#xd;
&#xd;
				// If we have data, let's convert it&#xd;
				} else {&#xd;
					statusText = response.state;&#xd;
					success = response.data;&#xd;
					error = response.error;&#xd;
					isSuccess = !error;&#xd;
				}&#xd;
			} else {&#xd;
				// We extract error from statusText&#xd;
				// then normalize statusText and status for non-aborts&#xd;
				error = statusText;&#xd;
				if ( status || !statusText ) {&#xd;
					statusText = "error";&#xd;
					if ( status &lt; 0 ) {&#xd;
						status = 0;&#xd;
					}&#xd;
				}&#xd;
			}&#xd;
&#xd;
			// Set data for the fake xhr object&#xd;
			jqXHR.status = status;&#xd;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";&#xd;
&#xd;
			// Success/Error&#xd;
			if ( isSuccess ) {&#xd;
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );&#xd;
			} else {&#xd;
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );&#xd;
			}&#xd;
&#xd;
			// Status-dependent callbacks&#xd;
			jqXHR.statusCode( statusCode );&#xd;
			statusCode = undefined;&#xd;
&#xd;
			if ( fireGlobals ) {&#xd;
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",&#xd;
					[ jqXHR, s, isSuccess ? success : error ] );&#xd;
			}&#xd;
&#xd;
			// Complete&#xd;
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );&#xd;
&#xd;
			if ( fireGlobals ) {&#xd;
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );&#xd;
				// Handle the global AJAX counter&#xd;
				if ( !( --jQuery.active ) ) {&#xd;
					jQuery.event.trigger("ajaxStop");&#xd;
				}&#xd;
			}&#xd;
		}&#xd;
&#xd;
		return jqXHR;&#xd;
	},&#xd;
&#xd;
	getJSON: function( url, data, callback ) {&#xd;
		return jQuery.get( url, data, callback, "json" );&#xd;
	},&#xd;
&#xd;
	getScript: function( url, callback ) {&#xd;
		return jQuery.get( url, undefined, callback, "script" );&#xd;
	}&#xd;
});&#xd;
&#xd;
jQuery.each( [ "get", "post" ], function( i, method ) {&#xd;
	jQuery[ method ] = function( url, data, callback, type ) {&#xd;
		// shift arguments if data argument was omitted&#xd;
		if ( jQuery.isFunction( data ) ) {&#xd;
			type = type || callback;&#xd;
			callback = data;&#xd;
			data = undefined;&#xd;
		}&#xd;
&#xd;
		return jQuery.ajax({&#xd;
			url: url,&#xd;
			type: method,&#xd;
			dataType: type,&#xd;
			data: data,&#xd;
			success: callback&#xd;
		});&#xd;
	};&#xd;
});&#xd;
&#xd;
// Attach a bunch of functions for handling common AJAX events&#xd;
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {&#xd;
	jQuery.fn[ type ] = function( fn ) {&#xd;
		return this.on( type, fn );&#xd;
	};&#xd;
});&#xd;
&#xd;
&#xd;
var r20 = /%20/g,&#xd;
	rbracket = /\[\]$/,&#xd;
	rCRLF = /\r?\n/g,&#xd;
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,&#xd;
	rsubmittable = /^(?:input|select|textarea|keygen)/i;&#xd;
&#xd;
function buildParams( prefix, obj, traditional, add ) {&#xd;
	var name;&#xd;
&#xd;
	if ( jQuery.isArray( obj ) ) {&#xd;
		// Serialize array item.&#xd;
		jQuery.each( obj, function( i, v ) {&#xd;
			if ( traditional || rbracket.test( prefix ) ) {&#xd;
				// Treat each array item as a scalar.&#xd;
				add( prefix, v );&#xd;
&#xd;
			} else {&#xd;
				// Item is non-scalar (array or object), encode its numeric index.&#xd;
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );&#xd;
			}&#xd;
		});&#xd;
&#xd;
	} else if ( !traditional &amp;&amp; jQuery.type( obj ) === "object" ) {&#xd;
		// Serialize object item.&#xd;
		for ( name in obj ) {&#xd;
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );&#xd;
		}&#xd;
&#xd;
	} else {&#xd;
		// Serialize scalar item.&#xd;
		add( prefix, obj );&#xd;
	}&#xd;
}&#xd;
&#xd;
// Serialize an array of form elements or a set of&#xd;
// key/values into a query string&#xd;
jQuery.param = function( a, traditional ) {&#xd;
	var prefix,&#xd;
		s = [],&#xd;
		add = function( key, value ) {&#xd;
			// If value is a function, invoke it and return its value&#xd;
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );&#xd;
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );&#xd;
		};&#xd;
&#xd;
	// Set traditional to true for jQuery &lt;= 1.3.2 behavior.&#xd;
	if ( traditional === undefined ) {&#xd;
		traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;&#xd;
	}&#xd;
&#xd;
	// If an array was passed in, assume that it is an array of form elements.&#xd;
	if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {&#xd;
		// Serialize the form elements&#xd;
		jQuery.each( a, function() {&#xd;
			add( this.name, this.value );&#xd;
		});&#xd;
&#xd;
	} else {&#xd;
		// If traditional, encode the "old" way (the way 1.3.2 or older&#xd;
		// did it), otherwise encode params recursively.&#xd;
		for ( prefix in a ) {&#xd;
			buildParams( prefix, a[ prefix ], traditional, add );&#xd;
		}&#xd;
	}&#xd;
&#xd;
	// Return the resulting serialization&#xd;
	return s.join( "&amp;" ).replace( r20, "+" );&#xd;
};&#xd;
&#xd;
jQuery.fn.extend({&#xd;
	serialize: function() {&#xd;
		return jQuery.param( this.serializeArray() );&#xd;
	},&#xd;
	serializeArray: function() {&#xd;
		return this.map(function() {&#xd;
			// Can add propHook for "elements" to filter or add form elements&#xd;
			var elements = jQuery.prop( this, "elements" );&#xd;
			return elements ? jQuery.makeArray( elements ) : this;&#xd;
		})&#xd;
		.filter(function() {&#xd;
			var type = this.type;&#xd;
&#xd;
			// Use .is( ":disabled" ) so that fieldset[disabled] works&#xd;
			return this.name &amp;&amp; !jQuery( this ).is( ":disabled" ) &amp;&amp;&#xd;
				rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;&#xd;
				( this.checked || !rcheckableType.test( type ) );&#xd;
		})&#xd;
		.map(function( i, elem ) {&#xd;
			var val = jQuery( this ).val();&#xd;
&#xd;
			return val == null ?&#xd;
				null :&#xd;
				jQuery.isArray( val ) ?&#xd;
					jQuery.map( val, function( val ) {&#xd;
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };&#xd;
					}) :&#xd;
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };&#xd;
		}).get();&#xd;
	}&#xd;
});&#xd;
&#xd;
&#xd;
jQuery.ajaxSettings.xhr = function() {&#xd;
	try {&#xd;
		return new XMLHttpRequest();&#xd;
	} catch( e ) {}&#xd;
};&#xd;
&#xd;
var xhrId = 0,&#xd;
	xhrCallbacks = {},&#xd;
	xhrSuccessStatus = {&#xd;
		// file protocol always yields status code 0, assume 200&#xd;
		0: 200,&#xd;
		// Support: IE9&#xd;
		// #1450: sometimes IE returns 1223 when it should be 204&#xd;
		1223: 204&#xd;
	},&#xd;
	xhrSupported = jQuery.ajaxSettings.xhr();&#xd;
&#xd;
// Support: IE9&#xd;
// Open requests must be manually aborted on unload (#5280)&#xd;
if ( window.ActiveXObject ) {&#xd;
	jQuery( window ).on( "unload", function() {&#xd;
		for ( var key in xhrCallbacks ) {&#xd;
			xhrCallbacks[ key ]();&#xd;
		}&#xd;
	});&#xd;
}&#xd;
&#xd;
support.cors = !!xhrSupported &amp;&amp; ( "withCredentials" in xhrSupported );&#xd;
support.ajax = xhrSupported = !!xhrSupported;&#xd;
&#xd;
jQuery.ajaxTransport(function( options ) {&#xd;
	var callback;&#xd;
&#xd;
	// Cross domain only allowed if supported through XMLHttpRequest&#xd;
	if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {&#xd;
		return {&#xd;
			send: function( headers, complete ) {&#xd;
				var i,&#xd;
					xhr = options.xhr(),&#xd;
					id = ++xhrId;&#xd;
&#xd;
				xhr.open( options.type, options.url, options.async, options.username, options.password );&#xd;
&#xd;
				// Apply custom fields if provided&#xd;
				if ( options.xhrFields ) {&#xd;
					for ( i in options.xhrFields ) {&#xd;
						xhr[ i ] = options.xhrFields[ i ];&#xd;
					}&#xd;
				}&#xd;
&#xd;
				// Override mime type if needed&#xd;
				if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {&#xd;
					xhr.overrideMimeType( options.mimeType );&#xd;
				}&#xd;
&#xd;
				// X-Requested-With header&#xd;
				// For cross-domain requests, seeing as conditions for a preflight are&#xd;
				// akin to a jigsaw puzzle, we simply never set it to be sure.&#xd;
				// (it can always be set on a per-request basis or even using ajaxSetup)&#xd;
				// For same-domain requests, won't change header if already provided.&#xd;
				if ( !options.crossDomain &amp;&amp; !headers["X-Requested-With"] ) {&#xd;
					headers["X-Requested-With"] = "XMLHttpRequest";&#xd;
				}&#xd;
&#xd;
				// Set headers&#xd;
				for ( i in headers ) {&#xd;
					xhr.setRequestHeader( i, headers[ i ] );&#xd;
				}&#xd;
&#xd;
				// Callback&#xd;
				callback = function( type ) {&#xd;
					return function() {&#xd;
						if ( callback ) {&#xd;
							delete xhrCallbacks[ id ];&#xd;
							callback = xhr.onload = xhr.onerror = null;&#xd;
&#xd;
							if ( type === "abort" ) {&#xd;
								xhr.abort();&#xd;
							} else if ( type === "error" ) {&#xd;
								complete(&#xd;
									// file: protocol always yields status 0; see #8605, #14207&#xd;
									xhr.status,&#xd;
									xhr.statusText&#xd;
								);&#xd;
							} else {&#xd;
								complete(&#xd;
									xhrSuccessStatus[ xhr.status ] || xhr.status,&#xd;
									xhr.statusText,&#xd;
									// Support: IE9&#xd;
									// Accessing binary-data responseText throws an exception&#xd;
									// (#11426)&#xd;
									typeof xhr.responseText === "string" ? {&#xd;
										text: xhr.responseText&#xd;
									} : undefined,&#xd;
									xhr.getAllResponseHeaders()&#xd;
								);&#xd;
							}&#xd;
						}&#xd;
					};&#xd;
				};&#xd;
&#xd;
				// Listen to events&#xd;
				xhr.onload = callback();&#xd;
				xhr.onerror = callback("error");&#xd;
&#xd;
				// Create the abort callback&#xd;
				callback = xhrCallbacks[ id ] = callback("abort");&#xd;
&#xd;
				try {&#xd;
					// Do send the request (this may raise an exception)&#xd;
					xhr.send( options.hasContent &amp;&amp; options.data || null );&#xd;
				} catch ( e ) {&#xd;
					// #14683: Only rethrow if this hasn't been notified as an error yet&#xd;
					if ( callback ) {&#xd;
						throw e;&#xd;
					}&#xd;
				}&#xd;
			},&#xd;
&#xd;
			abort: function() {&#xd;
				if ( callback ) {&#xd;
					callback();&#xd;
				}&#xd;
			}&#xd;
		};&#xd;
	}&#xd;
});&#xd;
&#xd;
&#xd;
&#xd;
&#xd;
// Install script dataType&#xd;
jQuery.ajaxSetup({&#xd;
	accepts: {&#xd;
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"&#xd;
	},&#xd;
	contents: {&#xd;
		script: /(?:java|ecma)script/&#xd;
	},&#xd;
	converters: {&#xd;
		"text script": function( text ) {&#xd;
			jQuery.globalEval( text );&#xd;
			return text;&#xd;
		}&#xd;
	}&#xd;
});&#xd;
&#xd;
// Handle cache's special case and crossDomain&#xd;
jQuery.ajaxPrefilter( "script", function( s ) {&#xd;
	if ( s.cache === undefined ) {&#xd;
		s.cache = false;&#xd;
	}&#xd;
	if ( s.crossDomain ) {&#xd;
		s.type = "GET";&#xd;
	}&#xd;
});&#xd;
&#xd;
// Bind script tag hack transport&#xd;
jQuery.ajaxTransport( "script", function( s ) {&#xd;
	// This transport only deals with cross domain requests&#xd;
	if ( s.crossDomain ) {&#xd;
		var script, callback;&#xd;
		return {&#xd;
			send: function( _, complete ) {&#xd;
				script = jQuery("&lt;script>").prop({&#xd;
					async: true,&#xd;
					charset: s.scriptCharset,&#xd;
					src: s.url&#xd;
				}).on(&#xd;
					"load error",&#xd;
					callback = function( evt ) {&#xd;
						script.remove();&#xd;
						callback = null;&#xd;
						if ( evt ) {&#xd;
							complete( evt.type === "error" ? 404 : 200, evt.type );&#xd;
						}&#xd;
					}&#xd;
				);&#xd;
				document.head.appendChild( script[ 0 ] );&#xd;
			},&#xd;
			abort: function() {&#xd;
				if ( callback ) {&#xd;
					callback();&#xd;
				}&#xd;
			}&#xd;
		};&#xd;
	}&#xd;
});&#xd;
&#xd;
&#xd;
&#xd;
&#xd;
var oldCallbacks = [],&#xd;
	rjsonp = /(=)\?(?=&amp;|$)|\?\?/;&#xd;
&#xd;
// Default jsonp settings&#xd;
jQuery.ajaxSetup({&#xd;
	jsonp: "callback",&#xd;
	jsonpCallback: function() {&#xd;
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );&#xd;
		this[ callback ] = true;&#xd;
		return callback;&#xd;
	}&#xd;
});&#xd;
&#xd;
// Detect, normalize options and install callbacks for jsonp requests&#xd;
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {&#xd;
&#xd;
	var callbackName, overwritten, responseContainer,&#xd;
		jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?&#xd;
			"url" :&#xd;
			typeof s.data === "string" &amp;&amp; !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &amp;&amp; rjsonp.test( s.data ) &amp;&amp; "data"&#xd;
		);&#xd;
&#xd;
	// Handle iff the expected data type is "jsonp" or we have a parameter to set&#xd;
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {&#xd;
&#xd;
		// Get callback name, remembering preexisting value associated with it&#xd;
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?&#xd;
			s.jsonpCallback() :&#xd;
			s.jsonpCallback;&#xd;
&#xd;
		// Insert callback into url or form data&#xd;
		if ( jsonProp ) {&#xd;
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );&#xd;
		} else if ( s.jsonp !== false ) {&#xd;
			s.url += ( rquery.test( s.url ) ? "&amp;" : "?" ) + s.jsonp + "=" + callbackName;&#xd;
		}&#xd;
&#xd;
		// Use data converter to retrieve json after script execution&#xd;
		s.converters["script json"] = function() {&#xd;
			if ( !responseContainer ) {&#xd;
				jQuery.error( callbackName + " was not called" );&#xd;
			}&#xd;
			return responseContainer[ 0 ];&#xd;
		};&#xd;
&#xd;
		// force json dataType&#xd;
		s.dataTypes[ 0 ] = "json";&#xd;
&#xd;
		// Install callback&#xd;
		overwritten = window[ callbackName ];&#xd;
		window[ callbackName ] = function() {&#xd;
			responseContainer = arguments;&#xd;
		};&#xd;
&#xd;
		// Clean-up function (fires after converters)&#xd;
		jqXHR.always(function() {&#xd;
			// Restore preexisting value&#xd;
			window[ callbackName ] = overwritten;&#xd;
&#xd;
			// Save back as free&#xd;
			if ( s[ callbackName ] ) {&#xd;
				// make sure that re-using the options doesn't screw things around&#xd;
				s.jsonpCallback = originalSettings.jsonpCallback;&#xd;
&#xd;
				// save the callback name for future use&#xd;
				oldCallbacks.push( callbackName );&#xd;
			}&#xd;
&#xd;
			// Call if it was a function and we have a response&#xd;
			if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {&#xd;
				overwritten( responseContainer[ 0 ] );&#xd;
			}&#xd;
&#xd;
			responseContainer = overwritten = undefined;&#xd;
		});&#xd;
&#xd;
		// Delegate to script&#xd;
		return "script";&#xd;
	}&#xd;
});&#xd;
&#xd;
&#xd;
&#xd;
&#xd;
// data: string of html&#xd;
// context (optional): If specified, the fragment will be created in this context, defaults to document&#xd;
// keepScripts (optional): If true, will include scripts passed in the html string&#xd;
jQuery.parseHTML = function( data, context, keepScripts ) {&#xd;
	if ( !data || typeof data !== "string" ) {&#xd;
		return null;&#xd;
	}&#xd;
	if ( typeof context === "boolean" ) {&#xd;
		keepScripts = context;&#xd;
		context = false;&#xd;
	}&#xd;
	context = context || document;&#xd;
&#xd;
	var parsed = rsingleTag.exec( data ),&#xd;
		scripts = !keepScripts &amp;&amp; [];&#xd;
&#xd;
	// Single tag&#xd;
	if ( parsed ) {&#xd;
		return [ context.createElement( parsed[1] ) ];&#xd;
	}&#xd;
&#xd;
	parsed = jQuery.buildFragment( [ data ], context, scripts );&#xd;
&#xd;
	if ( scripts &amp;&amp; scripts.length ) {&#xd;
		jQuery( scripts ).remove();&#xd;
	}&#xd;
&#xd;
	return jQuery.merge( [], parsed.childNodes );&#xd;
};&#xd;
&#xd;
&#xd;
// Keep a copy of the old load method&#xd;
var _load = jQuery.fn.load;&#xd;
&#xd;
/**&#xd;
 * Load a url into a page&#xd;
 */&#xd;
jQuery.fn.load = function( url, params, callback ) {&#xd;
	if ( typeof url !== "string" &amp;&amp; _load ) {&#xd;
		return _load.apply( this, arguments );&#xd;
	}&#xd;
&#xd;
	var selector, type, response,&#xd;
		self = this,&#xd;
		off = url.indexOf(" ");&#xd;
&#xd;
	if ( off >= 0 ) {&#xd;
		selector = jQuery.trim( url.slice( off ) );&#xd;
		url = url.slice( 0, off );&#xd;
	}&#xd;
&#xd;
	// If it's a function&#xd;
	if ( jQuery.isFunction( params ) ) {&#xd;
&#xd;
		// We assume that it's the callback&#xd;
		callback = params;&#xd;
		params = undefined;&#xd;
&#xd;
	// Otherwise, build a param string&#xd;
	} else if ( params &amp;&amp; typeof params === "object" ) {&#xd;
		type = "POST";&#xd;
	}&#xd;
&#xd;
	// If we have elements to modify, make the request&#xd;
	if ( self.length > 0 ) {&#xd;
		jQuery.ajax({&#xd;
			url: url,&#xd;
&#xd;
			// if "type" variable is undefined, then "GET" method will be used&#xd;
			type: type,&#xd;
			dataType: "html",&#xd;
			data: params&#xd;
		}).done(function( responseText ) {&#xd;
&#xd;
			// Save response for use in complete callback&#xd;
			response = arguments;&#xd;
&#xd;
			self.html( selector ?&#xd;
&#xd;
				// If a selector was specified, locate the right elements in a dummy div&#xd;
				// Exclude scripts to avoid IE 'Permission Denied' errors&#xd;
				jQuery("&lt;div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :&#xd;
&#xd;
				// Otherwise use the full result&#xd;
				responseText );&#xd;
&#xd;
		}).complete( callback &amp;&amp; function( jqXHR, status ) {&#xd;
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );&#xd;
		});&#xd;
	}&#xd;
&#xd;
	return this;&#xd;
};&#xd;
&#xd;
&#xd;
&#xd;
jQuery.noConflict = function() {};&#xd;
&#xd;
&#xd;
&#xd;
return jQuery;&#xd;
return jQuery;&#xd;
}));&#xd;
&#xd;
},{}],12:[function(require,module,exports){&#xd;
"use strict";&#xd;
module.exports = function(document) {&#xd;
  return {&#xd;
    reload: function() {&#xd;
      return document.location.reload();&#xd;
    },&#xd;
    getHash: function() {&#xd;
      return document.location.hash;&#xd;
    },&#xd;
    setHash: function(newHash) {&#xd;
      return document.location.hash = newHash;&#xd;
    },&#xd;
    changeHref: function(newLocation) {&#xd;
      return document.location.href = newLocation;&#xd;
    }&#xd;
  };&#xd;
};&#xd;
&#xd;
},{}],13:[function(require,module,exports){&#xd;
var b64pad, hexcase;&#xd;
&#xd;
hexcase = 0;&#xd;
&#xd;
b64pad = "";&#xd;
&#xd;
&#xd;
/* istanbul ignore next */&#xd;
&#xd;
module.exports = {&#xd;
  hex_sha1: function(s) {&#xd;
    return this.rstr2hex(this.rstr_sha1(this.str2rstr_utf8(s)));&#xd;
  },&#xd;
  b64_sha1: function(s) {&#xd;
    return this.rstr2b64(this.rstr_sha1(this.str2rstr_utf8(s)));&#xd;
  },&#xd;
  any_sha1: function(s, e) {&#xd;
    return this.rstr2any(this.rstr_sha1(this.str2rstr_utf8(s)), e);&#xd;
  },&#xd;
  hex_hmac_sha1: function(k, d) {&#xd;
    return this.rstr2hex(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));&#xd;
  },&#xd;
  b64_hmac_sha1: function(k, d) {&#xd;
    return this.rstr2b64(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));&#xd;
  },&#xd;
  any_hmac_sha1: function(k, d, e) {&#xd;
    return this.rstr2any(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)), e);&#xd;
  },&#xd;
  sha1_vm_test: function() {&#xd;
    return thishex_sha1("abc").toLowerCase() === "a9993e364706816aba3e25717850c26c9cd0d89d";&#xd;
  },&#xd;
  rstr_sha1: function(s) {&#xd;
    return this.binb2rstr(this.binb_sha1(this.rstr2binb(s), s.length * 8));&#xd;
  },&#xd;
  rstr_hmac_sha1: function(key, data) {&#xd;
    var bkey, hash, i, ipad, opad;&#xd;
    bkey = this.rstr2binb(key);&#xd;
    if (bkey.length > 16) {&#xd;
      bkey = this.binb_sha1(bkey, key.length * 8);&#xd;
    }&#xd;
    ipad = Array(16);&#xd;
    opad = Array(16);&#xd;
    i = 0;&#xd;
    while (i &lt; 16) {&#xd;
      ipad[i] = bkey[i] ^ 0x36363636;&#xd;
      opad[i] = bkey[i] ^ 0x5C5C5C5C;&#xd;
      i++;&#xd;
    }&#xd;
    hash = this.binb_sha1(ipad.concat(this.rstr2binb(data)), 512 + data.length * 8);&#xd;
    return this.binb2rstr(this.binb_sha1(opad.concat(hash), 512 + 160));&#xd;
  },&#xd;
  rstr2hex: function(input) {&#xd;
    var e, hex_tab, i, output, x;&#xd;
    try {&#xd;
      hexcase;&#xd;
    } catch (_error) {&#xd;
      e = _error;&#xd;
      hexcase = 0;&#xd;
    }&#xd;
    hex_tab = (hexcase ? "0123456789ABCDEF" : "0123456789abcdef");&#xd;
    output = "";&#xd;
    x = void 0;&#xd;
    i = 0;&#xd;
    while (i &lt; input.length) {&#xd;
      x = input.charCodeAt(i);&#xd;
      output += hex_tab.charAt((x >>> 4) &amp; 0x0F) + hex_tab.charAt(x &amp; 0x0F);&#xd;
      i++;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  rstr2b64: function(input) {&#xd;
    var e, i, j, len, output, tab, triplet;&#xd;
    try {&#xd;
      b64pad;&#xd;
    } catch (_error) {&#xd;
      e = _error;&#xd;
      b64pad = "";&#xd;
    }&#xd;
    tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";&#xd;
    output = "";&#xd;
    len = input.length;&#xd;
    i = 0;&#xd;
    while (i &lt; len) {&#xd;
      triplet = (input.charCodeAt(i) &lt;&lt; 16) | (i + 1 &lt; len ? input.charCodeAt(i + 1) &lt;&lt; 8 : 0) | (i + 2 &lt; len ? input.charCodeAt(i + 2) : 0);&#xd;
      j = 0;&#xd;
      while (j &lt; 4) {&#xd;
        if (i * 8 + j * 6 > input.length * 8) {&#xd;
          output += b64pad;&#xd;
        } else {&#xd;
          output += tab.charAt((triplet >>> 6 * (3 - j)) &amp; 0x3F);&#xd;
        }&#xd;
        j++;&#xd;
      }&#xd;
      i += 3;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  rstr2any: function(input, encoding) {&#xd;
    var dividend, divisor, full_length, i, output, q, quotient, remainders, x;&#xd;
    divisor = encoding.length;&#xd;
    remainders = Array();&#xd;
    i = void 0;&#xd;
    q = void 0;&#xd;
    x = void 0;&#xd;
    quotient = void 0;&#xd;
    dividend = Array(Math.ceil(input.length / 2));&#xd;
    i = 0;&#xd;
    while (i &lt; dividend.length) {&#xd;
      dividend[i] = (input.charCodeAt(i * 2) &lt;&lt; 8) | input.charCodeAt(i * 2 + 1);&#xd;
      i++;&#xd;
    }&#xd;
    while (dividend.length > 0) {&#xd;
      quotient = Array();&#xd;
      x = 0;&#xd;
      i = 0;&#xd;
      while (i &lt; dividend.length) {&#xd;
        x = (x &lt;&lt; 16) + dividend[i];&#xd;
        q = Math.floor(x / divisor);&#xd;
        x -= q * divisor;&#xd;
        if (quotient.length > 0 || q > 0) {&#xd;
          quotient[quotient.length] = q;&#xd;
        }&#xd;
        i++;&#xd;
      }&#xd;
      remainders[remainders.length] = x;&#xd;
      dividend = quotient;&#xd;
    }&#xd;
    output = "";&#xd;
    i = remainders.length - 1;&#xd;
    while (i >= 0) {&#xd;
      output += encoding.charAt(remainders[i]);&#xd;
      i--;&#xd;
    }&#xd;
    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));&#xd;
    i = output.length;&#xd;
    while (i &lt; full_length) {&#xd;
      output = encoding[0] + output;&#xd;
      i++;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  str2rstr_utf8: function(input) {&#xd;
    var i, output, x, y;&#xd;
    output = "";&#xd;
    i = -1;&#xd;
    x = void 0;&#xd;
    y = void 0;&#xd;
    while (++i &lt; input.length) {&#xd;
      x = input.charCodeAt(i);&#xd;
      y = (i + 1 &lt; input.length ? input.charCodeAt(i + 1) : 0);&#xd;
      if (0xD800 &lt;= x &amp;&amp; x &lt;= 0xDBFF &amp;&amp; 0xDC00 &lt;= y &amp;&amp; y &lt;= 0xDFFF) {&#xd;
        x = 0x10000 + ((x &amp; 0x03FF) &lt;&lt; 10) + (y &amp; 0x03FF);&#xd;
        i++;&#xd;
      }&#xd;
      if (x &lt;= 0x7F) {&#xd;
        output += String.fromCharCode(x);&#xd;
      } else if (x &lt;= 0x7FF) {&#xd;
        output += String.fromCharCode(0xC0 | ((x >>> 6) &amp; 0x1F), 0x80 | (x &amp; 0x3F));&#xd;
      } else if (x &lt;= 0xFFFF) {&#xd;
        output += String.fromCharCode(0xE0 | ((x >>> 12) &amp; 0x0F), 0x80 | ((x >>> 6) &amp; 0x3F), 0x80 | (x &amp; 0x3F));&#xd;
      } else {&#xd;
        if (x &lt;= 0x1FFFFF) {&#xd;
          output += String.fromCharCode(0xF0 | ((x >>> 18) &amp; 0x07), 0x80 | ((x >>> 12) &amp; 0x3F), 0x80 | ((x >>> 6) &amp; 0x3F), 0x80 | (x &amp; 0x3F));&#xd;
        }&#xd;
      }&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  str2rstr_utf16le: function(input) {&#xd;
    var i, output;&#xd;
    output = "";&#xd;
    i = 0;&#xd;
    while (i &lt; input.length) {&#xd;
      output += String.fromCharCode(input.charCodeAt(i) &amp; 0xFF, (input.charCodeAt(i) >>> 8) &amp; 0xFF);&#xd;
      i++;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  str2rstr_utf16be: function(input) {&#xd;
    var i, output;&#xd;
    output = "";&#xd;
    i = 0;&#xd;
    while (i &lt; input.length) {&#xd;
      output += String.fromCharCode((input.charCodeAt(i) >>> 8) &amp; 0xFF, input.charCodeAt(i) &amp; 0xFF);&#xd;
      i++;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  rstr2binb: function(input) {&#xd;
    var i, output;&#xd;
    output = Array(input.length >> 2);&#xd;
    i = 0;&#xd;
    while (i &lt; output.length) {&#xd;
      output[i] = 0;&#xd;
      i++;&#xd;
    }&#xd;
    i = 0;&#xd;
    while (i &lt; input.length * 8) {&#xd;
      output[i >> 5] |= (input.charCodeAt(i / 8) &amp; 0xFF) &lt;&lt; (24 - i % 32);&#xd;
      i += 8;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  binb2rstr: function(input) {&#xd;
    var i, output;&#xd;
    output = "";&#xd;
    i = 0;&#xd;
    while (i &lt; input.length * 32) {&#xd;
      output += String.fromCharCode((input[i >> 5] >>> (24 - i % 32)) &amp; 0xFF);&#xd;
      i += 8;&#xd;
    }&#xd;
    return output;&#xd;
  },&#xd;
  binb_sha1: function(x, len) {&#xd;
    var a, b, c, d, e, i, j, olda, oldb, oldc, oldd, olde, t, w;&#xd;
    x[len >> 5] |= 0x80 &lt;&lt; (24 - len % 32);&#xd;
    x[((len + 64 >> 9) &lt;&lt; 4) + 15] = len;&#xd;
    w = Array(80);&#xd;
    a = 1732584193;&#xd;
    b = -271733879;&#xd;
    c = -1732584194;&#xd;
    d = 271733878;&#xd;
    e = -1009589776;&#xd;
    i = 0;&#xd;
    while (i &lt; x.length) {&#xd;
      olda = a;&#xd;
      oldb = b;&#xd;
      oldc = c;&#xd;
      oldd = d;&#xd;
      olde = e;&#xd;
      j = 0;&#xd;
      while (j &lt; 80) {&#xd;
        if (j &lt; 16) {&#xd;
          w[j] = x[i + j];&#xd;
        } else {&#xd;
          w[j] = this.bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);&#xd;
        }&#xd;
        t = this.safe_add(this.safe_add(this.bit_rol(a, 5), this.sha1_ft(j, b, c, d)), this.safe_add(this.safe_add(e, w[j]), this.sha1_kt(j)));&#xd;
        e = d;&#xd;
        d = c;&#xd;
        c = this.bit_rol(b, 30);&#xd;
        b = a;&#xd;
        a = t;&#xd;
        j++;&#xd;
      }&#xd;
      a = this.safe_add(a, olda);&#xd;
      b = this.safe_add(b, oldb);&#xd;
      c = this.safe_add(c, oldc);&#xd;
      d = this.safe_add(d, oldd);&#xd;
      e = this.safe_add(e, olde);&#xd;
      i += 16;&#xd;
    }&#xd;
    return Array(a, b, c, d, e);&#xd;
  },&#xd;
  sha1_ft: function(t, b, c, d) {&#xd;
    if (t &lt; 20) {&#xd;
      return (b &amp; c) | ((~b) &amp; d);&#xd;
    }&#xd;
    if (t &lt; 40) {&#xd;
      return b ^ c ^ d;&#xd;
    }&#xd;
    if (t &lt; 60) {&#xd;
      return (b &amp; c) | (b &amp; d) | (c &amp; d);&#xd;
    }&#xd;
    return b ^ c ^ d;&#xd;
  },&#xd;
  sha1_kt: function(t) {&#xd;
    if (t &lt; 20) {&#xd;
      return 1518500249;&#xd;
    } else {&#xd;
      if (t &lt; 40) {&#xd;
        return 1859775393;&#xd;
      } else {&#xd;
        if (t &lt; 60) {&#xd;
          return -1894007588;&#xd;
        } else {&#xd;
          return -899497514;&#xd;
        }&#xd;
      }&#xd;
    }&#xd;
  },&#xd;
  safe_add: function(x, y) {&#xd;
    var lsw, msw;&#xd;
    lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);&#xd;
    msw = (x >> 16) + (y >> 16) + (lsw >> 16);&#xd;
    return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#xd;
  },&#xd;
  bit_rol: function(num, cnt) {&#xd;
    return (num &lt;&lt; cnt) | (num >>> (32 - cnt));&#xd;
  },&#xd;
  create_hash: function() {&#xd;
    var hash;&#xd;
    hash = this.b64_sha1((new Date()).getTime() + ":" + Math.floor(Math.random() * 9999999));&#xd;
    return hash.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=+$/, "");&#xd;
  }&#xd;
};&#xd;
&#xd;
},{}],14:[function(require,module,exports){&#xd;
module.exports = function(document) {&#xd;
  return {&#xd;
    getAbsUrl: function(url) {&#xd;
      var base_url;&#xd;
      if (url.match(/^.{2,5}:\/\//)) {&#xd;
        return url;&#xd;
      }&#xd;
      if (url[0] === "/") {&#xd;
        return document.location.protocol + "//" + document.location.host + url;&#xd;
      }&#xd;
      base_url = document.location.protocol + "//" + document.location.host + document.location.pathname;&#xd;
      if (base_url[base_url.length - 1] !== "/" &amp;&amp; url[0] !== "#") {&#xd;
        return base_url + "/" + url;&#xd;
      }&#xd;
      return base_url + url;&#xd;
    },&#xd;
    replaceParam: function(param, rep, rep2) {&#xd;
      param = param.replace(/\{\{(.*?)\}\}/g, function(m, v) {&#xd;
        return rep[v] || "";&#xd;
      });&#xd;
      if (rep2) {&#xd;
        param = param.replace(/\{(.*?)\}/g, function(m, v) {&#xd;
          return rep2[v] || "";&#xd;
        });&#xd;
      }&#xd;
      return param;&#xd;
    }&#xd;
  };&#xd;
};&#xd;
&#xd;
},{}],15:[function(require,module,exports){&#xd;
// shim for using process in browser&#xd;
&#xd;
var process = module.exports = {};&#xd;
&#xd;
process.nextTick = (function () {&#xd;
    var canSetImmediate = typeof window !== 'undefined'&#xd;
    &amp;&amp; window.setImmediate;&#xd;
    var canPost = typeof window !== 'undefined'&#xd;
    &amp;&amp; window.postMessage &amp;&amp; window.addEventListener&#xd;
    ;&#xd;
&#xd;
    if (canSetImmediate) {&#xd;
        return function (f) { return window.setImmediate(f) };&#xd;
    }&#xd;
&#xd;
    if (canPost) {&#xd;
        var queue = [];&#xd;
        window.addEventListener('message', function (ev) {&#xd;
            var source = ev.source;&#xd;
            if ((source === window || source === null) &amp;&amp; ev.data === 'process-tick') {&#xd;
                ev.stopPropagation();&#xd;
                if (queue.length > 0) {&#xd;
                    var fn = queue.shift();&#xd;
                    fn();&#xd;
                }&#xd;
            }&#xd;
        }, true);&#xd;
&#xd;
        return function nextTick(fn) {&#xd;
            queue.push(fn);&#xd;
            window.postMessage('process-tick', '*');&#xd;
        };&#xd;
    }&#xd;
&#xd;
    return function nextTick(fn) {&#xd;
        setTimeout(fn, 0);&#xd;
    };&#xd;
})();&#xd;
&#xd;
process.title = 'browser';&#xd;
process.browser = true;&#xd;
process.env = {};&#xd;
process.argv = [];&#xd;
&#xd;
process.binding = function (name) {&#xd;
    throw new Error('process.binding is not supported');&#xd;
}&#xd;
&#xd;
// TODO(shtylman)&#xd;
process.cwd = function () { return '/' };&#xd;
process.chdir = function (dir) {&#xd;
    throw new Error('process.chdir is not supported');&#xd;
};&#xd;
&#xd;
},{}],16:[function(require,module,exports){&#xd;
(function (process){&#xd;
// vim:ts=4:sts=4:sw=4:&#xd;
/*!&#xd;
 *&#xd;
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT&#xd;
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE&#xd;
 *&#xd;
 * With parts by Tyler Close&#xd;
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found&#xd;
 * at http://www.opensource.org/licenses/mit-license.html&#xd;
 * Forked at ref_send.js version: 2009-05-11&#xd;
 *&#xd;
 * With parts by Mark Miller&#xd;
 * Copyright (C) 2011 Google Inc.&#xd;
 *&#xd;
 * Licensed under the Apache License, Version 2.0 (the "License");&#xd;
 * you may not use this file except in compliance with the License.&#xd;
 * You may obtain a copy of the License at&#xd;
 *&#xd;
 * http://www.apache.org/licenses/LICENSE-2.0&#xd;
 *&#xd;
 * Unless required by applicable law or agreed to in writing, software&#xd;
 * distributed under the License is distributed on an "AS IS" BASIS,&#xd;
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#xd;
 * See the License for the specific language governing permissions and&#xd;
 * limitations under the License.&#xd;
 *&#xd;
 */&#xd;
&#xd;
(function (definition) {&#xd;
    "use strict";&#xd;
&#xd;
    // This file will function properly as a &lt;script> tag, or a module&#xd;
    // using CommonJS and NodeJS or RequireJS module formats.  In&#xd;
    // Common/Node/RequireJS, the module exports the Q API and when&#xd;
    // executed as a simple &lt;script>, it creates a Q global instead.&#xd;
&#xd;
    // Montage Require&#xd;
    if (typeof bootstrap === "function") {&#xd;
        bootstrap("promise", definition);&#xd;
&#xd;
    // CommonJS&#xd;
    } else if (typeof exports === "object" &amp;&amp; typeof module === "object") {&#xd;
        module.exports = definition();&#xd;
&#xd;
    // RequireJS&#xd;
    } else if (typeof define === "function" &amp;&amp; define.amd) {&#xd;
        define(definition);&#xd;
&#xd;
    // SES (Secure EcmaScript)&#xd;
    } else if (typeof ses !== "undefined") {&#xd;
        if (!ses.ok()) {&#xd;
            return;&#xd;
        } else {&#xd;
            ses.makeQ = definition;&#xd;
        }&#xd;
&#xd;
    // &lt;script>&#xd;
    } else if (typeof self !== "undefined") {&#xd;
        self.Q = definition();&#xd;
&#xd;
    } else {&#xd;
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");&#xd;
    }&#xd;
&#xd;
})(function () {&#xd;
"use strict";&#xd;
&#xd;
var hasStacks = false;&#xd;
try {&#xd;
    throw new Error();&#xd;
} catch (e) {&#xd;
    hasStacks = !!e.stack;&#xd;
}&#xd;
&#xd;
// All code after this point will be filtered from stack traces reported&#xd;
// by Q.&#xd;
var qStartingLine = captureLine();&#xd;
var qFileName;&#xd;
&#xd;
// shims&#xd;
&#xd;
// used for fallback in "allResolved"&#xd;
var noop = function () {};&#xd;
&#xd;
// Use the fastest possible means to execute a task in a future turn&#xd;
// of the event loop.&#xd;
var nextTick =(function () {&#xd;
    // linked list of tasks (single, with head node)&#xd;
    var head = {task: void 0, next: null};&#xd;
    var tail = head;&#xd;
    var flushing = false;&#xd;
    var requestTick = void 0;&#xd;
    var isNodeJS = false;&#xd;
&#xd;
    function flush() {&#xd;
        /* jshint loopfunc: true */&#xd;
&#xd;
        while (head.next) {&#xd;
            head = head.next;&#xd;
            var task = head.task;&#xd;
            head.task = void 0;&#xd;
            var domain = head.domain;&#xd;
&#xd;
            if (domain) {&#xd;
                head.domain = void 0;&#xd;
                domain.enter();&#xd;
            }&#xd;
&#xd;
            try {&#xd;
                task();&#xd;
&#xd;
            } catch (e) {&#xd;
                if (isNodeJS) {&#xd;
                    // In node, uncaught exceptions are considered fatal errors.&#xd;
                    // Re-throw them synchronously to interrupt flushing!&#xd;
&#xd;
                    // Ensure continuation if the uncaught exception is suppressed&#xd;
                    // listening "uncaughtException" events (as domains does).&#xd;
                    // Continue in next event to avoid tick recursion.&#xd;
                    if (domain) {&#xd;
                        domain.exit();&#xd;
                    }&#xd;
                    setTimeout(flush, 0);&#xd;
                    if (domain) {&#xd;
                        domain.enter();&#xd;
                    }&#xd;
&#xd;
                    throw e;&#xd;
&#xd;
                } else {&#xd;
                    // In browsers, uncaught exceptions are not fatal.&#xd;
                    // Re-throw them asynchronously to avoid slow-downs.&#xd;
                    setTimeout(function() {&#xd;
                       throw e;&#xd;
                    }, 0);&#xd;
                }&#xd;
            }&#xd;
&#xd;
            if (domain) {&#xd;
                domain.exit();&#xd;
            }&#xd;
        }&#xd;
&#xd;
        flushing = false;&#xd;
    }&#xd;
&#xd;
    nextTick = function (task) {&#xd;
        tail = tail.next = {&#xd;
            task: task,&#xd;
            domain: isNodeJS &amp;&amp; process.domain,&#xd;
            next: null&#xd;
        };&#xd;
&#xd;
        if (!flushing) {&#xd;
            flushing = true;&#xd;
            requestTick();&#xd;
        }&#xd;
    };&#xd;
&#xd;
    if (typeof process !== "undefined" &amp;&amp; process.nextTick) {&#xd;
        // Node.js before 0.9. Note that some fake-Node environments, like the&#xd;
        // Mocha test runner, introduce a `process` global without a `nextTick`.&#xd;
        isNodeJS = true;&#xd;
&#xd;
        requestTick = function () {&#xd;
            process.nextTick(flush);&#xd;
        };&#xd;
&#xd;
    } else if (typeof setImmediate === "function") {&#xd;
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate&#xd;
        if (typeof window !== "undefined") {&#xd;
            requestTick = setImmediate.bind(window, flush);&#xd;
        } else {&#xd;
            requestTick = function () {&#xd;
                setImmediate(flush);&#xd;
            };&#xd;
        }&#xd;
&#xd;
    } else if (typeof MessageChannel !== "undefined") {&#xd;
        // modern browsers&#xd;
        // http://www.nonblocking.io/2011/06/windownexttick.html&#xd;
        var channel = new MessageChannel();&#xd;
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create&#xd;
        // working message ports the first time a page loads.&#xd;
        channel.port1.onmessage = function () {&#xd;
            requestTick = requestPortTick;&#xd;
            channel.port1.onmessage = flush;&#xd;
            flush();&#xd;
        };&#xd;
        var requestPortTick = function () {&#xd;
            // Opera requires us to provide a message payload, regardless of&#xd;
            // whether we use it.&#xd;
            channel.port2.postMessage(0);&#xd;
        };&#xd;
        requestTick = function () {&#xd;
            setTimeout(flush, 0);&#xd;
            requestPortTick();&#xd;
        };&#xd;
&#xd;
    } else {&#xd;
        // old browsers&#xd;
        requestTick = function () {&#xd;
            setTimeout(flush, 0);&#xd;
        };&#xd;
    }&#xd;
&#xd;
    return nextTick;&#xd;
})();&#xd;
&#xd;
// Attempt to make generics safe in the face of downstream&#xd;
// modifications.&#xd;
// There is no situation where this is necessary.&#xd;
// If you need a security guarantee, these primordials need to be&#xd;
// deeply frozen anyway, and if you dont need a security guarantee,&#xd;
// this is just plain paranoid.&#xd;
// However, this **might** have the nice side-effect of reducing the size of&#xd;
// the minified code by reducing x.call() to merely x()&#xd;
// See Mark Millers explanation of what this does.&#xd;
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming&#xd;
var call = Function.call;&#xd;
function uncurryThis(f) {&#xd;
    return function () {&#xd;
        return call.apply(f, arguments);&#xd;
    };&#xd;
}&#xd;
// This is equivalent, but slower:&#xd;
// uncurryThis = Function_bind.bind(Function_bind.call);&#xd;
// http://jsperf.com/uncurrythis&#xd;
&#xd;
var array_slice = uncurryThis(Array.prototype.slice);&#xd;
&#xd;
var array_reduce = uncurryThis(&#xd;
    Array.prototype.reduce || function (callback, basis) {&#xd;
        var index = 0,&#xd;
            length = this.length;&#xd;
        // concerning the initial value, if one is not provided&#xd;
        if (arguments.length === 1) {&#xd;
            // seek to the first value in the array, accounting&#xd;
            // for the possibility that is is a sparse array&#xd;
            do {&#xd;
                if (index in this) {&#xd;
                    basis = this[index++];&#xd;
                    break;&#xd;
                }&#xd;
                if (++index >= length) {&#xd;
                    throw new TypeError();&#xd;
                }&#xd;
            } while (1);&#xd;
        }&#xd;
        // reduce&#xd;
        for (; index &lt; length; index++) {&#xd;
            // account for the possibility that the array is sparse&#xd;
            if (index in this) {&#xd;
                basis = callback(basis, this[index], index);&#xd;
            }&#xd;
        }&#xd;
        return basis;&#xd;
    }&#xd;
);&#xd;
&#xd;
var array_indexOf = uncurryThis(&#xd;
    Array.prototype.indexOf || function (value) {&#xd;
        // not a very good shim, but good enough for our one use of it&#xd;
        for (var i = 0; i &lt; this.length; i++) {&#xd;
            if (this[i] === value) {&#xd;
                return i;&#xd;
            }&#xd;
        }&#xd;
        return -1;&#xd;
    }&#xd;
);&#xd;
&#xd;
var array_map = uncurryThis(&#xd;
    Array.prototype.map || function (callback, thisp) {&#xd;
        var self = this;&#xd;
        var collect = [];&#xd;
        array_reduce(self, function (undefined, value, index) {&#xd;
            collect.push(callback.call(thisp, value, index, self));&#xd;
        }, void 0);&#xd;
        return collect;&#xd;
    }&#xd;
);&#xd;
&#xd;
var object_create = Object.create || function (prototype) {&#xd;
    function Type() { }&#xd;
    Type.prototype = prototype;&#xd;
    return new Type();&#xd;
};&#xd;
&#xd;
var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);&#xd;
&#xd;
var object_keys = Object.keys || function (object) {&#xd;
    var keys = [];&#xd;
    for (var key in object) {&#xd;
        if (object_hasOwnProperty(object, key)) {&#xd;
            keys.push(key);&#xd;
        }&#xd;
    }&#xd;
    return keys;&#xd;
};&#xd;
&#xd;
var object_toString = uncurryThis(Object.prototype.toString);&#xd;
&#xd;
function isObject(value) {&#xd;
    return value === Object(value);&#xd;
}&#xd;
&#xd;
// generator related shims&#xd;
&#xd;
// FIXME: Remove this function once ES6 generators are in SpiderMonkey.&#xd;
function isStopIteration(exception) {&#xd;
    return (&#xd;
        object_toString(exception) === "[object StopIteration]" ||&#xd;
        exception instanceof QReturnValue&#xd;
    );&#xd;
}&#xd;
&#xd;
// FIXME: Remove this helper and Q.return once ES6 generators are in&#xd;
// SpiderMonkey.&#xd;
var QReturnValue;&#xd;
if (typeof ReturnValue !== "undefined") {&#xd;
    QReturnValue = ReturnValue;&#xd;
} else {&#xd;
    QReturnValue = function (value) {&#xd;
        this.value = value;&#xd;
    };&#xd;
}&#xd;
&#xd;
// long stack traces&#xd;
&#xd;
var STACK_JUMP_SEPARATOR = "From previous event:";&#xd;
&#xd;
function makeStackTraceLong(error, promise) {&#xd;
    // If possible, transform the error stack trace by removing Node and Q&#xd;
    // cruft, then concatenating with the stack trace of `promise`. See #57.&#xd;
    if (hasStacks &amp;&amp;&#xd;
        promise.stack &amp;&amp;&#xd;
        typeof error === "object" &amp;&amp;&#xd;
        error !== null &amp;&amp;&#xd;
        error.stack &amp;&amp;&#xd;
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1&#xd;
    ) {&#xd;
        var stacks = [];&#xd;
        for (var p = promise; !!p; p = p.source) {&#xd;
            if (p.stack) {&#xd;
                stacks.unshift(p.stack);&#xd;
            }&#xd;
        }&#xd;
        stacks.unshift(error.stack);&#xd;
&#xd;
        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");&#xd;
        error.stack = filterStackString(concatedStacks);&#xd;
    }&#xd;
}&#xd;
&#xd;
function filterStackString(stackString) {&#xd;
    var lines = stackString.split("\n");&#xd;
    var desiredLines = [];&#xd;
    for (var i = 0; i &lt; lines.length; ++i) {&#xd;
        var line = lines[i];&#xd;
&#xd;
        if (!isInternalFrame(line) &amp;&amp; !isNodeFrame(line) &amp;&amp; line) {&#xd;
            desiredLines.push(line);&#xd;
        }&#xd;
    }&#xd;
    return desiredLines.join("\n");&#xd;
}&#xd;
&#xd;
function isNodeFrame(stackLine) {&#xd;
    return stackLine.indexOf("(module.js:") !== -1 ||&#xd;
           stackLine.indexOf("(node.js:") !== -1;&#xd;
}&#xd;
&#xd;
function getFileNameAndLineNumber(stackLine) {&#xd;
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"&#xd;
    // In IE10 function name can have spaces ("Anonymous function") O_o&#xd;
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);&#xd;
    if (attempt1) {&#xd;
        return [attempt1[1], Number(attempt1[2])];&#xd;
    }&#xd;
&#xd;
    // Anonymous functions: "at filename:lineNumber:columnNumber"&#xd;
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);&#xd;
    if (attempt2) {&#xd;
        return [attempt2[1], Number(attempt2[2])];&#xd;
    }&#xd;
&#xd;
    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"&#xd;
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);&#xd;
    if (attempt3) {&#xd;
        return [attempt3[1], Number(attempt3[2])];&#xd;
    }&#xd;
}&#xd;
&#xd;
function isInternalFrame(stackLine) {&#xd;
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);&#xd;
&#xd;
    if (!fileNameAndLineNumber) {&#xd;
        return false;&#xd;
    }&#xd;
&#xd;
    var fileName = fileNameAndLineNumber[0];&#xd;
    var lineNumber = fileNameAndLineNumber[1];&#xd;
&#xd;
    return fileName === qFileName &amp;&amp;&#xd;
        lineNumber >= qStartingLine &amp;&amp;&#xd;
        lineNumber &lt;= qEndingLine;&#xd;
}&#xd;
&#xd;
// discover own file name and line number range for filtering stack&#xd;
// traces&#xd;
function captureLine() {&#xd;
    if (!hasStacks) {&#xd;
        return;&#xd;
    }&#xd;
&#xd;
    try {&#xd;
        throw new Error();&#xd;
    } catch (e) {&#xd;
        var lines = e.stack.split("\n");&#xd;
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];&#xd;
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);&#xd;
        if (!fileNameAndLineNumber) {&#xd;
            return;&#xd;
        }&#xd;
&#xd;
        qFileName = fileNameAndLineNumber[0];&#xd;
        return fileNameAndLineNumber[1];&#xd;
    }&#xd;
}&#xd;
&#xd;
function deprecate(callback, name, alternative) {&#xd;
    return function () {&#xd;
        if (typeof console !== "undefined" &amp;&amp;&#xd;
            typeof console.warn === "function") {&#xd;
            console.warn(name + " is deprecated, use " + alternative +&#xd;
                         " instead.", new Error("").stack);&#xd;
        }&#xd;
        return callback.apply(callback, arguments);&#xd;
    };&#xd;
}&#xd;
&#xd;
// end of shims&#xd;
// beginning of real work&#xd;
&#xd;
/**&#xd;
 * Constructs a promise for an immediate reference, passes promises through, or&#xd;
 * coerces promises from different systems.&#xd;
 * @param value immediate reference or promise&#xd;
 */&#xd;
function Q(value) {&#xd;
    // If the object is already a Promise, return it directly.  This enables&#xd;
    // the resolve function to both be used to created references from objects,&#xd;
    // but to tolerably coerce non-promises to promises.&#xd;
    if (value instanceof Promise) {&#xd;
        return value;&#xd;
    }&#xd;
&#xd;
    // assimilate thenables&#xd;
    if (isPromiseAlike(value)) {&#xd;
        return coerce(value);&#xd;
    } else {&#xd;
        return fulfill(value);&#xd;
    }&#xd;
}&#xd;
Q.resolve = Q;&#xd;
&#xd;
/**&#xd;
 * Performs a task in a future turn of the event loop.&#xd;
 * @param {Function} task&#xd;
 */&#xd;
Q.nextTick = nextTick;&#xd;
&#xd;
/**&#xd;
 * Controls whether or not long stack traces will be on&#xd;
 */&#xd;
Q.longStackSupport = false;&#xd;
&#xd;
// enable long stacks if Q_DEBUG is set&#xd;
if (typeof process === "object" &amp;&amp; process &amp;&amp; process.env &amp;&amp; process.env.Q_DEBUG) {&#xd;
    Q.longStackSupport = true;&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Constructs a {promise, resolve, reject} object.&#xd;
 *&#xd;
 * `resolve` is a callback to invoke with a more resolved value for the&#xd;
 * promise. To fulfill the promise, invoke `resolve` with any value that is&#xd;
 * not a thenable. To reject the promise, invoke `resolve` with a rejected&#xd;
 * thenable, or invoke `reject` with the reason directly. To resolve the&#xd;
 * promise to another thenable, thus putting it in the same state, invoke&#xd;
 * `resolve` with that other thenable.&#xd;
 */&#xd;
Q.defer = defer;&#xd;
function defer() {&#xd;
    // if "messages" is an "Array", that indicates that the promise has not yet&#xd;
    // been resolved.  If it is "undefined", it has been resolved.  Each&#xd;
    // element of the messages array is itself an array of complete arguments to&#xd;
    // forward to the resolved promise.  We coerce the resolution value to a&#xd;
    // promise using the `resolve` function because it handles both fully&#xd;
    // non-thenable values and other thenables gracefully.&#xd;
    var messages = [], progressListeners = [], resolvedPromise;&#xd;
&#xd;
    var deferred = object_create(defer.prototype);&#xd;
    var promise = object_create(Promise.prototype);&#xd;
&#xd;
    promise.promiseDispatch = function (resolve, op, operands) {&#xd;
        var args = array_slice(arguments);&#xd;
        if (messages) {&#xd;
            messages.push(args);&#xd;
            if (op === "when" &amp;&amp; operands[1]) { // progress operand&#xd;
                progressListeners.push(operands[1]);&#xd;
            }&#xd;
        } else {&#xd;
            Q.nextTick(function () {&#xd;
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);&#xd;
            });&#xd;
        }&#xd;
    };&#xd;
&#xd;
    // XXX deprecated&#xd;
    promise.valueOf = function () {&#xd;
        if (messages) {&#xd;
            return promise;&#xd;
        }&#xd;
        var nearerValue = nearer(resolvedPromise);&#xd;
        if (isPromise(nearerValue)) {&#xd;
            resolvedPromise = nearerValue; // shorten chain&#xd;
        }&#xd;
        return nearerValue;&#xd;
    };&#xd;
&#xd;
    promise.inspect = function () {&#xd;
        if (!resolvedPromise) {&#xd;
            return { state: "pending" };&#xd;
        }&#xd;
        return resolvedPromise.inspect();&#xd;
    };&#xd;
&#xd;
    if (Q.longStackSupport &amp;&amp; hasStacks) {&#xd;
        try {&#xd;
            throw new Error();&#xd;
        } catch (e) {&#xd;
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the&#xd;
            // accessor around; that causes memory leaks as per GH-111. Just&#xd;
            // reify the stack trace as a string ASAP.&#xd;
            //&#xd;
            // At the same time, cut off the first line; it's always just&#xd;
            // "[object Promise]\n", as per the `toString`.&#xd;
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);&#xd;
        }&#xd;
    }&#xd;
&#xd;
    // NOTE: we do the checks for `resolvedPromise` in each method, instead of&#xd;
    // consolidating them into `become`, since otherwise we'd create new&#xd;
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.&#xd;
&#xd;
    function become(newPromise) {&#xd;
        resolvedPromise = newPromise;&#xd;
        promise.source = newPromise;&#xd;
&#xd;
        array_reduce(messages, function (undefined, message) {&#xd;
            Q.nextTick(function () {&#xd;
                newPromise.promiseDispatch.apply(newPromise, message);&#xd;
            });&#xd;
        }, void 0);&#xd;
&#xd;
        messages = void 0;&#xd;
        progressListeners = void 0;&#xd;
    }&#xd;
&#xd;
    deferred.promise = promise;&#xd;
    deferred.resolve = function (value) {&#xd;
        if (resolvedPromise) {&#xd;
            return;&#xd;
        }&#xd;
&#xd;
        become(Q(value));&#xd;
    };&#xd;
&#xd;
    deferred.fulfill = function (value) {&#xd;
        if (resolvedPromise) {&#xd;
            return;&#xd;
        }&#xd;
&#xd;
        become(fulfill(value));&#xd;
    };&#xd;
    deferred.reject = function (reason) {&#xd;
        if (resolvedPromise) {&#xd;
            return;&#xd;
        }&#xd;
&#xd;
        become(reject(reason));&#xd;
    };&#xd;
    deferred.notify = function (progress) {&#xd;
        if (resolvedPromise) {&#xd;
            return;&#xd;
        }&#xd;
&#xd;
        array_reduce(progressListeners, function (undefined, progressListener) {&#xd;
            Q.nextTick(function () {&#xd;
                progressListener(progress);&#xd;
            });&#xd;
        }, void 0);&#xd;
    };&#xd;
&#xd;
    return deferred;&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Creates a Node-style callback that will resolve or reject the deferred&#xd;
 * promise.&#xd;
 * @returns a nodeback&#xd;
 */&#xd;
defer.prototype.makeNodeResolver = function () {&#xd;
    var self = this;&#xd;
    return function (error, value) {&#xd;
        if (error) {&#xd;
            self.reject(error);&#xd;
        } else if (arguments.length > 2) {&#xd;
            self.resolve(array_slice(arguments, 1));&#xd;
        } else {&#xd;
            self.resolve(value);&#xd;
        }&#xd;
    };&#xd;
};&#xd;
&#xd;
/**&#xd;
 * @param resolver {Function} a function that returns nothing and accepts&#xd;
 * the resolve, reject, and notify functions for a deferred.&#xd;
 * @returns a promise that may be resolved with the given resolve and reject&#xd;
 * functions, or rejected by a thrown exception in resolver&#xd;
 */&#xd;
Q.Promise = promise; // ES6&#xd;
Q.promise = promise;&#xd;
function promise(resolver) {&#xd;
    if (typeof resolver !== "function") {&#xd;
        throw new TypeError("resolver must be a function.");&#xd;
    }&#xd;
    var deferred = defer();&#xd;
    try {&#xd;
        resolver(deferred.resolve, deferred.reject, deferred.notify);&#xd;
    } catch (reason) {&#xd;
        deferred.reject(reason);&#xd;
    }&#xd;
    return deferred.promise;&#xd;
}&#xd;
&#xd;
promise.race = race; // ES6&#xd;
promise.all = all; // ES6&#xd;
promise.reject = reject; // ES6&#xd;
promise.resolve = Q; // ES6&#xd;
&#xd;
// XXX experimental.  This method is a way to denote that a local value is&#xd;
// serializable and should be immediately dispatched to a remote upon request,&#xd;
// instead of passing a reference.&#xd;
Q.passByCopy = function (object) {&#xd;
    //freeze(object);&#xd;
    //passByCopies.set(object, true);&#xd;
    return object;&#xd;
};&#xd;
&#xd;
Promise.prototype.passByCopy = function () {&#xd;
    //freeze(object);&#xd;
    //passByCopies.set(object, true);&#xd;
    return this;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * If two promises eventually fulfill to the same value, promises that value,&#xd;
 * but otherwise rejects.&#xd;
 * @param x {Any*}&#xd;
 * @param y {Any*}&#xd;
 * @returns {Any*} a promise for x and y if they are the same, but a rejection&#xd;
 * otherwise.&#xd;
 *&#xd;
 */&#xd;
Q.join = function (x, y) {&#xd;
    return Q(x).join(y);&#xd;
};&#xd;
&#xd;
Promise.prototype.join = function (that) {&#xd;
    return Q([this, that]).spread(function (x, y) {&#xd;
        if (x === y) {&#xd;
            // TODO: "===" should be Object.is or equiv&#xd;
            return x;&#xd;
        } else {&#xd;
            throw new Error("Can't join: not the same: " + x + " " + y);&#xd;
        }&#xd;
    });&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Returns a promise for the first of an array of promises to become settled.&#xd;
 * @param answers {Array[Any*]} promises to race&#xd;
 * @returns {Any*} the first promise to be settled&#xd;
 */&#xd;
Q.race = race;&#xd;
function race(answerPs) {&#xd;
    return promise(function(resolve, reject) {&#xd;
        // Switch to this once we can assume at least ES5&#xd;
        // answerPs.forEach(function(answerP) {&#xd;
        //     Q(answerP).then(resolve, reject);&#xd;
        // });&#xd;
        // Use this in the meantime&#xd;
        for (var i = 0, len = answerPs.length; i &lt; len; i++) {&#xd;
            Q(answerPs[i]).then(resolve, reject);&#xd;
        }&#xd;
    });&#xd;
}&#xd;
&#xd;
Promise.prototype.race = function () {&#xd;
    return this.then(Q.race);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Constructs a Promise with a promise descriptor object and optional fallback&#xd;
 * function.  The descriptor contains methods like when(rejected), get(name),&#xd;
 * set(name, value), post(name, args), and delete(name), which all&#xd;
 * return either a value, a promise for a value, or a rejection.  The fallback&#xd;
 * accepts the operation name, a resolver, and any further arguments that would&#xd;
 * have been forwarded to the appropriate method above had a method been&#xd;
 * provided with the proper name.  The API makes no guarantees about the nature&#xd;
 * of the returned object, apart from that it is usable whereever promises are&#xd;
 * bought and sold.&#xd;
 */&#xd;
Q.makePromise = Promise;&#xd;
function Promise(descriptor, fallback, inspect) {&#xd;
    if (fallback === void 0) {&#xd;
        fallback = function (op) {&#xd;
            return reject(new Error(&#xd;
                "Promise does not support operation: " + op&#xd;
            ));&#xd;
        };&#xd;
    }&#xd;
    if (inspect === void 0) {&#xd;
        inspect = function () {&#xd;
            return {state: "unknown"};&#xd;
        };&#xd;
    }&#xd;
&#xd;
    var promise = object_create(Promise.prototype);&#xd;
&#xd;
    promise.promiseDispatch = function (resolve, op, args) {&#xd;
        var result;&#xd;
        try {&#xd;
            if (descriptor[op]) {&#xd;
                result = descriptor[op].apply(promise, args);&#xd;
            } else {&#xd;
                result = fallback.call(promise, op, args);&#xd;
            }&#xd;
        } catch (exception) {&#xd;
            result = reject(exception);&#xd;
        }&#xd;
        if (resolve) {&#xd;
            resolve(result);&#xd;
        }&#xd;
    };&#xd;
&#xd;
    promise.inspect = inspect;&#xd;
&#xd;
    // XXX deprecated `valueOf` and `exception` support&#xd;
    if (inspect) {&#xd;
        var inspected = inspect();&#xd;
        if (inspected.state === "rejected") {&#xd;
            promise.exception = inspected.reason;&#xd;
        }&#xd;
&#xd;
        promise.valueOf = function () {&#xd;
            var inspected = inspect();&#xd;
            if (inspected.state === "pending" ||&#xd;
                inspected.state === "rejected") {&#xd;
                return promise;&#xd;
            }&#xd;
            return inspected.value;&#xd;
        };&#xd;
    }&#xd;
&#xd;
    return promise;&#xd;
}&#xd;
&#xd;
Promise.prototype.toString = function () {&#xd;
    return "[object Promise]";&#xd;
};&#xd;
&#xd;
Promise.prototype.then = function (fulfilled, rejected, progressed) {&#xd;
    var self = this;&#xd;
    var deferred = defer();&#xd;
    var done = false;   // ensure the untrusted promise makes at most a&#xd;
                        // single call to one of the callbacks&#xd;
&#xd;
    function _fulfilled(value) {&#xd;
        try {&#xd;
            return typeof fulfilled === "function" ? fulfilled(value) : value;&#xd;
        } catch (exception) {&#xd;
            return reject(exception);&#xd;
        }&#xd;
    }&#xd;
&#xd;
    function _rejected(exception) {&#xd;
        if (typeof rejected === "function") {&#xd;
            makeStackTraceLong(exception, self);&#xd;
            try {&#xd;
                return rejected(exception);&#xd;
            } catch (newException) {&#xd;
                return reject(newException);&#xd;
            }&#xd;
        }&#xd;
        return reject(exception);&#xd;
    }&#xd;
&#xd;
    function _progressed(value) {&#xd;
        return typeof progressed === "function" ? progressed(value) : value;&#xd;
    }&#xd;
&#xd;
    Q.nextTick(function () {&#xd;
        self.promiseDispatch(function (value) {&#xd;
            if (done) {&#xd;
                return;&#xd;
            }&#xd;
            done = true;&#xd;
&#xd;
            deferred.resolve(_fulfilled(value));&#xd;
        }, "when", [function (exception) {&#xd;
            if (done) {&#xd;
                return;&#xd;
            }&#xd;
            done = true;&#xd;
&#xd;
            deferred.resolve(_rejected(exception));&#xd;
        }]);&#xd;
    });&#xd;
&#xd;
    // Progress propagator need to be attached in the current tick.&#xd;
    self.promiseDispatch(void 0, "when", [void 0, function (value) {&#xd;
        var newValue;&#xd;
        var threw = false;&#xd;
        try {&#xd;
            newValue = _progressed(value);&#xd;
        } catch (e) {&#xd;
            threw = true;&#xd;
            if (Q.onerror) {&#xd;
                Q.onerror(e);&#xd;
            } else {&#xd;
                throw e;&#xd;
            }&#xd;
        }&#xd;
&#xd;
        if (!threw) {&#xd;
            deferred.notify(newValue);&#xd;
        }&#xd;
    }]);&#xd;
&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
Q.tap = function (promise, callback) {&#xd;
    return Q(promise).tap(callback);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Works almost like "finally", but not called for rejections.&#xd;
 * Original resolution value is passed through callback unaffected.&#xd;
 * Callback may return a promise that will be awaited for.&#xd;
 * @param {Function} callback&#xd;
 * @returns {Q.Promise}&#xd;
 * @example&#xd;
 * doSomething()&#xd;
 *   .then(...)&#xd;
 *   .tap(console.log)&#xd;
 *   .then(...);&#xd;
 */&#xd;
Promise.prototype.tap = function (callback) {&#xd;
    callback = Q(callback);&#xd;
&#xd;
    return this.then(function (value) {&#xd;
        return callback.fcall(value).thenResolve(value);&#xd;
    });&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Registers an observer on a promise.&#xd;
 *&#xd;
 * Guarantees:&#xd;
 *&#xd;
 * 1. that fulfilled and rejected will be called only once.&#xd;
 * 2. that either the fulfilled callback or the rejected callback will be&#xd;
 *    called, but not both.&#xd;
 * 3. that fulfilled and rejected will not be called in this turn.&#xd;
 *&#xd;
 * @param value      promise or immediate reference to observe&#xd;
 * @param fulfilled  function to be called with the fulfilled value&#xd;
 * @param rejected   function to be called with the rejection exception&#xd;
 * @param progressed function to be called on any progress notifications&#xd;
 * @return promise for the return value from the invoked callback&#xd;
 */&#xd;
Q.when = when;&#xd;
function when(value, fulfilled, rejected, progressed) {&#xd;
    return Q(value).then(fulfilled, rejected, progressed);&#xd;
}&#xd;
&#xd;
Promise.prototype.thenResolve = function (value) {&#xd;
    return this.then(function () { return value; });&#xd;
};&#xd;
&#xd;
Q.thenResolve = function (promise, value) {&#xd;
    return Q(promise).thenResolve(value);&#xd;
};&#xd;
&#xd;
Promise.prototype.thenReject = function (reason) {&#xd;
    return this.then(function () { throw reason; });&#xd;
};&#xd;
&#xd;
Q.thenReject = function (promise, reason) {&#xd;
    return Q(promise).thenReject(reason);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * If an object is not a promise, it is as "near" as possible.&#xd;
 * If a promise is rejected, it is as "near" as possible too.&#xd;
 * If its a fulfilled promise, the fulfillment value is nearer.&#xd;
 * If its a deferred promise and the deferred has been resolved, the&#xd;
 * resolution is "nearer".&#xd;
 * @param object&#xd;
 * @returns most resolved (nearest) form of the object&#xd;
 */&#xd;
&#xd;
// XXX should we re-do this?&#xd;
Q.nearer = nearer;&#xd;
function nearer(value) {&#xd;
    if (isPromise(value)) {&#xd;
        var inspected = value.inspect();&#xd;
        if (inspected.state === "fulfilled") {&#xd;
            return inspected.value;&#xd;
        }&#xd;
    }&#xd;
    return value;&#xd;
}&#xd;
&#xd;
/**&#xd;
 * @returns whether the given object is a promise.&#xd;
 * Otherwise it is a fulfilled value.&#xd;
 */&#xd;
Q.isPromise = isPromise;&#xd;
function isPromise(object) {&#xd;
    return object instanceof Promise;&#xd;
}&#xd;
&#xd;
Q.isPromiseAlike = isPromiseAlike;&#xd;
function isPromiseAlike(object) {&#xd;
    return isObject(object) &amp;&amp; typeof object.then === "function";&#xd;
}&#xd;
&#xd;
/**&#xd;
 * @returns whether the given object is a pending promise, meaning not&#xd;
 * fulfilled or rejected.&#xd;
 */&#xd;
Q.isPending = isPending;&#xd;
function isPending(object) {&#xd;
    return isPromise(object) &amp;&amp; object.inspect().state === "pending";&#xd;
}&#xd;
&#xd;
Promise.prototype.isPending = function () {&#xd;
    return this.inspect().state === "pending";&#xd;
};&#xd;
&#xd;
/**&#xd;
 * @returns whether the given object is a value or fulfilled&#xd;
 * promise.&#xd;
 */&#xd;
Q.isFulfilled = isFulfilled;&#xd;
function isFulfilled(object) {&#xd;
    return !isPromise(object) || object.inspect().state === "fulfilled";&#xd;
}&#xd;
&#xd;
Promise.prototype.isFulfilled = function () {&#xd;
    return this.inspect().state === "fulfilled";&#xd;
};&#xd;
&#xd;
/**&#xd;
 * @returns whether the given object is a rejected promise.&#xd;
 */&#xd;
Q.isRejected = isRejected;&#xd;
function isRejected(object) {&#xd;
    return isPromise(object) &amp;&amp; object.inspect().state === "rejected";&#xd;
}&#xd;
&#xd;
Promise.prototype.isRejected = function () {&#xd;
    return this.inspect().state === "rejected";&#xd;
};&#xd;
&#xd;
//// BEGIN UNHANDLED REJECTION TRACKING&#xd;
&#xd;
// This promise library consumes exceptions thrown in handlers so they can be&#xd;
// handled by a subsequent promise.  The exceptions get added to this array when&#xd;
// they are created, and removed when they are handled.  Note that in ES6 or&#xd;
// shimmed environments, this would naturally be a `Set`.&#xd;
var unhandledReasons = [];&#xd;
var unhandledRejections = [];&#xd;
var trackUnhandledRejections = true;&#xd;
&#xd;
function resetUnhandledRejections() {&#xd;
    unhandledReasons.length = 0;&#xd;
    unhandledRejections.length = 0;&#xd;
&#xd;
    if (!trackUnhandledRejections) {&#xd;
        trackUnhandledRejections = true;&#xd;
    }&#xd;
}&#xd;
&#xd;
function trackRejection(promise, reason) {&#xd;
    if (!trackUnhandledRejections) {&#xd;
        return;&#xd;
    }&#xd;
&#xd;
    unhandledRejections.push(promise);&#xd;
    if (reason &amp;&amp; typeof reason.stack !== "undefined") {&#xd;
        unhandledReasons.push(reason.stack);&#xd;
    } else {&#xd;
        unhandledReasons.push("(no stack) " + reason);&#xd;
    }&#xd;
}&#xd;
&#xd;
function untrackRejection(promise) {&#xd;
    if (!trackUnhandledRejections) {&#xd;
        return;&#xd;
    }&#xd;
&#xd;
    var at = array_indexOf(unhandledRejections, promise);&#xd;
    if (at !== -1) {&#xd;
        unhandledRejections.splice(at, 1);&#xd;
        unhandledReasons.splice(at, 1);&#xd;
    }&#xd;
}&#xd;
&#xd;
Q.resetUnhandledRejections = resetUnhandledRejections;&#xd;
&#xd;
Q.getUnhandledReasons = function () {&#xd;
    // Make a copy so that consumers can't interfere with our internal state.&#xd;
    return unhandledReasons.slice();&#xd;
};&#xd;
&#xd;
Q.stopUnhandledRejectionTracking = function () {&#xd;
    resetUnhandledRejections();&#xd;
    trackUnhandledRejections = false;&#xd;
};&#xd;
&#xd;
resetUnhandledRejections();&#xd;
&#xd;
//// END UNHANDLED REJECTION TRACKING&#xd;
&#xd;
/**&#xd;
 * Constructs a rejected promise.&#xd;
 * @param reason value describing the failure&#xd;
 */&#xd;
Q.reject = reject;&#xd;
function reject(reason) {&#xd;
    var rejection = Promise({&#xd;
        "when": function (rejected) {&#xd;
            // note that the error has been handled&#xd;
            if (rejected) {&#xd;
                untrackRejection(this);&#xd;
            }&#xd;
            return rejected ? rejected(reason) : this;&#xd;
        }&#xd;
    }, function fallback() {&#xd;
        return this;&#xd;
    }, function inspect() {&#xd;
        return { state: "rejected", reason: reason };&#xd;
    });&#xd;
&#xd;
    // Note that the reason has not been handled.&#xd;
    trackRejection(rejection, reason);&#xd;
&#xd;
    return rejection;&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Constructs a fulfilled promise for an immediate reference.&#xd;
 * @param value immediate reference&#xd;
 */&#xd;
Q.fulfill = fulfill;&#xd;
function fulfill(value) {&#xd;
    return Promise({&#xd;
        "when": function () {&#xd;
            return value;&#xd;
        },&#xd;
        "get": function (name) {&#xd;
            return value[name];&#xd;
        },&#xd;
        "set": function (name, rhs) {&#xd;
            value[name] = rhs;&#xd;
        },&#xd;
        "delete": function (name) {&#xd;
            delete value[name];&#xd;
        },&#xd;
        "post": function (name, args) {&#xd;
            // Mark Miller proposes that post with no name should apply a&#xd;
            // promised function.&#xd;
            if (name === null || name === void 0) {&#xd;
                return value.apply(void 0, args);&#xd;
            } else {&#xd;
                return value[name].apply(value, args);&#xd;
            }&#xd;
        },&#xd;
        "apply": function (thisp, args) {&#xd;
            return value.apply(thisp, args);&#xd;
        },&#xd;
        "keys": function () {&#xd;
            return object_keys(value);&#xd;
        }&#xd;
    }, void 0, function inspect() {&#xd;
        return { state: "fulfilled", value: value };&#xd;
    });&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Converts thenables to Q promises.&#xd;
 * @param promise thenable promise&#xd;
 * @returns a Q promise&#xd;
 */&#xd;
function coerce(promise) {&#xd;
    var deferred = defer();&#xd;
    Q.nextTick(function () {&#xd;
        try {&#xd;
            promise.then(deferred.resolve, deferred.reject, deferred.notify);&#xd;
        } catch (exception) {&#xd;
            deferred.reject(exception);&#xd;
        }&#xd;
    });&#xd;
    return deferred.promise;&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Annotates an object such that it will never be&#xd;
 * transferred away from this process over any promise&#xd;
 * communication channel.&#xd;
 * @param object&#xd;
 * @returns promise a wrapping of that object that&#xd;
 * additionally responds to the "isDef" message&#xd;
 * without a rejection.&#xd;
 */&#xd;
Q.master = master;&#xd;
function master(object) {&#xd;
    return Promise({&#xd;
        "isDef": function () {}&#xd;
    }, function fallback(op, args) {&#xd;
        return dispatch(object, op, args);&#xd;
    }, function () {&#xd;
        return Q(object).inspect();&#xd;
    });&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Spreads the values of a promised array of arguments into the&#xd;
 * fulfillment callback.&#xd;
 * @param fulfilled callback that receives variadic arguments from the&#xd;
 * promised array&#xd;
 * @param rejected callback that receives the exception if the promise&#xd;
 * is rejected.&#xd;
 * @returns a promise for the return value or thrown exception of&#xd;
 * either callback.&#xd;
 */&#xd;
Q.spread = spread;&#xd;
function spread(value, fulfilled, rejected) {&#xd;
    return Q(value).spread(fulfilled, rejected);&#xd;
}&#xd;
&#xd;
Promise.prototype.spread = function (fulfilled, rejected) {&#xd;
    return this.all().then(function (array) {&#xd;
        return fulfilled.apply(void 0, array);&#xd;
    }, rejected);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * The async function is a decorator for generator functions, turning&#xd;
 * them into asynchronous generators.  Although generators are only part&#xd;
 * of the newest ECMAScript 6 drafts, this code does not cause syntax&#xd;
 * errors in older engines.  This code should continue to work and will&#xd;
 * in fact improve over time as the language improves.&#xd;
 *&#xd;
 * ES6 generators are currently part of V8 version 3.19 with the&#xd;
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them&#xd;
 * for longer, but under an older Python-inspired form.  This function&#xd;
 * works on both kinds of generators.&#xd;
 *&#xd;
 * Decorates a generator function such that:&#xd;
 *  - it may yield promises&#xd;
 *  - execution will continue when that promise is fulfilled&#xd;
 *  - the value of the yield expression will be the fulfilled value&#xd;
 *  - it returns a promise for the return value (when the generator&#xd;
 *    stops iterating)&#xd;
 *  - the decorated function returns a promise for the return value&#xd;
 *    of the generator or the first rejected promise among those&#xd;
 *    yielded.&#xd;
 *  - if an error is thrown in the generator, it propagates through&#xd;
 *    every following yield until it is caught, or until it escapes&#xd;
 *    the generator function altogether, and is translated into a&#xd;
 *    rejection for the promise returned by the decorated generator.&#xd;
 */&#xd;
Q.async = async;&#xd;
function async(makeGenerator) {&#xd;
    return function () {&#xd;
        // when verb is "send", arg is a value&#xd;
        // when verb is "throw", arg is an exception&#xd;
        function continuer(verb, arg) {&#xd;
            var result;&#xd;
&#xd;
            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only&#xd;
            // engine that has a deployed base of browsers that support generators.&#xd;
            // However, SM's generators use the Python-inspired semantics of&#xd;
            // outdated ES6 drafts.  We would like to support ES6, but we'd also&#xd;
            // like to make it possible to use generators in deployed browsers, so&#xd;
            // we also support Python-style generators.  At some point we can remove&#xd;
            // this block.&#xd;
&#xd;
            if (typeof StopIteration === "undefined") {&#xd;
                // ES6 Generators&#xd;
                try {&#xd;
                    result = generator[verb](arg);&#xd;
                } catch (exception) {&#xd;
                    return reject(exception);&#xd;
                }&#xd;
                if (result.done) {&#xd;
                    return Q(result.value);&#xd;
                } else {&#xd;
                    return when(result.value, callback, errback);&#xd;
                }&#xd;
            } else {&#xd;
                // SpiderMonkey Generators&#xd;
                // FIXME: Remove this case when SM does ES6 generators.&#xd;
                try {&#xd;
                    result = generator[verb](arg);&#xd;
                } catch (exception) {&#xd;
                    if (isStopIteration(exception)) {&#xd;
                        return Q(exception.value);&#xd;
                    } else {&#xd;
                        return reject(exception);&#xd;
                    }&#xd;
                }&#xd;
                return when(result, callback, errback);&#xd;
            }&#xd;
        }&#xd;
        var generator = makeGenerator.apply(this, arguments);&#xd;
        var callback = continuer.bind(continuer, "next");&#xd;
        var errback = continuer.bind(continuer, "throw");&#xd;
        return callback();&#xd;
    };&#xd;
}&#xd;
&#xd;
/**&#xd;
 * The spawn function is a small wrapper around async that immediately&#xd;
 * calls the generator and also ends the promise chain, so that any&#xd;
 * unhandled errors are thrown instead of forwarded to the error&#xd;
 * handler. This is useful because it's extremely common to run&#xd;
 * generators at the top-level to work with libraries.&#xd;
 */&#xd;
Q.spawn = spawn;&#xd;
function spawn(makeGenerator) {&#xd;
    Q.done(Q.async(makeGenerator)());&#xd;
}&#xd;
&#xd;
// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.&#xd;
/**&#xd;
 * Throws a ReturnValue exception to stop an asynchronous generator.&#xd;
 *&#xd;
 * This interface is a stop-gap measure to support generator return&#xd;
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6&#xd;
 * generators like Chromium 29, just use "return" in your generator&#xd;
 * functions.&#xd;
 *&#xd;
 * @param value the return value for the surrounding generator&#xd;
 * @throws ReturnValue exception with the value.&#xd;
 * @example&#xd;
 * // ES6 style&#xd;
 * Q.async(function* () {&#xd;
 *      var foo = yield getFooPromise();&#xd;
 *      var bar = yield getBarPromise();&#xd;
 *      return foo + bar;&#xd;
 * })&#xd;
 * // Older SpiderMonkey style&#xd;
 * Q.async(function () {&#xd;
 *      var foo = yield getFooPromise();&#xd;
 *      var bar = yield getBarPromise();&#xd;
 *      Q.return(foo + bar);&#xd;
 * })&#xd;
 */&#xd;
Q["return"] = _return;&#xd;
function _return(value) {&#xd;
    throw new QReturnValue(value);&#xd;
}&#xd;
&#xd;
/**&#xd;
 * The promised function decorator ensures that any promise arguments&#xd;
 * are settled and passed as values (`this` is also settled and passed&#xd;
 * as a value).  It will also ensure that the result of a function is&#xd;
 * always a promise.&#xd;
 *&#xd;
 * @example&#xd;
 * var add = Q.promised(function (a, b) {&#xd;
 *     return a + b;&#xd;
 * });&#xd;
 * add(Q(a), Q(B));&#xd;
 *&#xd;
 * @param {function} callback The function to decorate&#xd;
 * @returns {function} a function that has been decorated.&#xd;
 */&#xd;
Q.promised = promised;&#xd;
function promised(callback) {&#xd;
    return function () {&#xd;
        return spread([this, all(arguments)], function (self, args) {&#xd;
            return callback.apply(self, args);&#xd;
        });&#xd;
    };&#xd;
}&#xd;
&#xd;
/**&#xd;
 * sends a message to a value in a future turn&#xd;
 * @param object* the recipient&#xd;
 * @param op the name of the message operation, e.g., "when",&#xd;
 * @param args further arguments to be forwarded to the operation&#xd;
 * @returns result {Promise} a promise for the result of the operation&#xd;
 */&#xd;
Q.dispatch = dispatch;&#xd;
function dispatch(object, op, args) {&#xd;
    return Q(object).dispatch(op, args);&#xd;
}&#xd;
&#xd;
Promise.prototype.dispatch = function (op, args) {&#xd;
    var self = this;&#xd;
    var deferred = defer();&#xd;
    Q.nextTick(function () {&#xd;
        self.promiseDispatch(deferred.resolve, op, args);&#xd;
    });&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Gets the value of a property in a future turn.&#xd;
 * @param object    promise or immediate reference for target object&#xd;
 * @param name      name of property to get&#xd;
 * @return promise for the property value&#xd;
 */&#xd;
Q.get = function (object, key) {&#xd;
    return Q(object).dispatch("get", [key]);&#xd;
};&#xd;
&#xd;
Promise.prototype.get = function (key) {&#xd;
    return this.dispatch("get", [key]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Sets the value of a property in a future turn.&#xd;
 * @param object    promise or immediate reference for object object&#xd;
 * @param name      name of property to set&#xd;
 * @param value     new value of property&#xd;
 * @return promise for the return value&#xd;
 */&#xd;
Q.set = function (object, key, value) {&#xd;
    return Q(object).dispatch("set", [key, value]);&#xd;
};&#xd;
&#xd;
Promise.prototype.set = function (key, value) {&#xd;
    return this.dispatch("set", [key, value]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Deletes a property in a future turn.&#xd;
 * @param object    promise or immediate reference for target object&#xd;
 * @param name      name of property to delete&#xd;
 * @return promise for the return value&#xd;
 */&#xd;
Q.del = // XXX legacy&#xd;
Q["delete"] = function (object, key) {&#xd;
    return Q(object).dispatch("delete", [key]);&#xd;
};&#xd;
&#xd;
Promise.prototype.del = // XXX legacy&#xd;
Promise.prototype["delete"] = function (key) {&#xd;
    return this.dispatch("delete", [key]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Invokes a method in a future turn.&#xd;
 * @param object    promise or immediate reference for target object&#xd;
 * @param name      name of method to invoke&#xd;
 * @param value     a value to post, typically an array of&#xd;
 *                  invocation arguments for promises that&#xd;
 *                  are ultimately backed with `resolve` values,&#xd;
 *                  as opposed to those backed with URLs&#xd;
 *                  wherein the posted value can be any&#xd;
 *                  JSON serializable object.&#xd;
 * @return promise for the return value&#xd;
 */&#xd;
// bound locally because it is used by other methods&#xd;
Q.mapply = // XXX As proposed by "Redsandro"&#xd;
Q.post = function (object, name, args) {&#xd;
    return Q(object).dispatch("post", [name, args]);&#xd;
};&#xd;
&#xd;
Promise.prototype.mapply = // XXX As proposed by "Redsandro"&#xd;
Promise.prototype.post = function (name, args) {&#xd;
    return this.dispatch("post", [name, args]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Invokes a method in a future turn.&#xd;
 * @param object    promise or immediate reference for target object&#xd;
 * @param name      name of method to invoke&#xd;
 * @param ...args   array of invocation arguments&#xd;
 * @return promise for the return value&#xd;
 */&#xd;
Q.send = // XXX Mark Miller's proposed parlance&#xd;
Q.mcall = // XXX As proposed by "Redsandro"&#xd;
Q.invoke = function (object, name /*...args*/) {&#xd;
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);&#xd;
};&#xd;
&#xd;
Promise.prototype.send = // XXX Mark Miller's proposed parlance&#xd;
Promise.prototype.mcall = // XXX As proposed by "Redsandro"&#xd;
Promise.prototype.invoke = function (name /*...args*/) {&#xd;
    return this.dispatch("post", [name, array_slice(arguments, 1)]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Applies the promised function in a future turn.&#xd;
 * @param object    promise or immediate reference for target function&#xd;
 * @param args      array of application arguments&#xd;
 */&#xd;
Q.fapply = function (object, args) {&#xd;
    return Q(object).dispatch("apply", [void 0, args]);&#xd;
};&#xd;
&#xd;
Promise.prototype.fapply = function (args) {&#xd;
    return this.dispatch("apply", [void 0, args]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Calls the promised function in a future turn.&#xd;
 * @param object    promise or immediate reference for target function&#xd;
 * @param ...args   array of application arguments&#xd;
 */&#xd;
Q["try"] =&#xd;
Q.fcall = function (object /* ...args*/) {&#xd;
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);&#xd;
};&#xd;
&#xd;
Promise.prototype.fcall = function (/*...args*/) {&#xd;
    return this.dispatch("apply", [void 0, array_slice(arguments)]);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Binds the promised function, transforming return values into a fulfilled&#xd;
 * promise and thrown errors into a rejected one.&#xd;
 * @param object    promise or immediate reference for target function&#xd;
 * @param ...args   array of application arguments&#xd;
 */&#xd;
Q.fbind = function (object /*...args*/) {&#xd;
    var promise = Q(object);&#xd;
    var args = array_slice(arguments, 1);&#xd;
    return function fbound() {&#xd;
        return promise.dispatch("apply", [&#xd;
            this,&#xd;
            args.concat(array_slice(arguments))&#xd;
        ]);&#xd;
    };&#xd;
};&#xd;
Promise.prototype.fbind = function (/*...args*/) {&#xd;
    var promise = this;&#xd;
    var args = array_slice(arguments);&#xd;
    return function fbound() {&#xd;
        return promise.dispatch("apply", [&#xd;
            this,&#xd;
            args.concat(array_slice(arguments))&#xd;
        ]);&#xd;
    };&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Requests the names of the owned properties of a promised&#xd;
 * object in a future turn.&#xd;
 * @param object    promise or immediate reference for target object&#xd;
 * @return promise for the keys of the eventually settled object&#xd;
 */&#xd;
Q.keys = function (object) {&#xd;
    return Q(object).dispatch("keys", []);&#xd;
};&#xd;
&#xd;
Promise.prototype.keys = function () {&#xd;
    return this.dispatch("keys", []);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Turns an array of promises into a promise for an array.  If any of&#xd;
 * the promises gets rejected, the whole array is rejected immediately.&#xd;
 * @param {Array*} an array (or promise for an array) of values (or&#xd;
 * promises for values)&#xd;
 * @returns a promise for an array of the corresponding values&#xd;
 */&#xd;
// By Mark Miller&#xd;
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&amp;rev=1308776521#allfulfilled&#xd;
Q.all = all;&#xd;
function all(promises) {&#xd;
    return when(promises, function (promises) {&#xd;
        var countDown = 0;&#xd;
        var deferred = defer();&#xd;
        array_reduce(promises, function (undefined, promise, index) {&#xd;
            var snapshot;&#xd;
            if (&#xd;
                isPromise(promise) &amp;&amp;&#xd;
                (snapshot = promise.inspect()).state === "fulfilled"&#xd;
            ) {&#xd;
                promises[index] = snapshot.value;&#xd;
            } else {&#xd;
                ++countDown;&#xd;
                when(&#xd;
                    promise,&#xd;
                    function (value) {&#xd;
                        promises[index] = value;&#xd;
                        if (--countDown === 0) {&#xd;
                            deferred.resolve(promises);&#xd;
                        }&#xd;
                    },&#xd;
                    deferred.reject,&#xd;
                    function (progress) {&#xd;
                        deferred.notify({ index: index, value: progress });&#xd;
                    }&#xd;
                );&#xd;
            }&#xd;
        }, void 0);&#xd;
        if (countDown === 0) {&#xd;
            deferred.resolve(promises);&#xd;
        }&#xd;
        return deferred.promise;&#xd;
    });&#xd;
}&#xd;
&#xd;
Promise.prototype.all = function () {&#xd;
    return all(this);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Waits for all promises to be settled, either fulfilled or&#xd;
 * rejected.  This is distinct from `all` since that would stop&#xd;
 * waiting at the first rejection.  The promise returned by&#xd;
 * `allResolved` will never be rejected.&#xd;
 * @param promises a promise for an array (or an array) of promises&#xd;
 * (or values)&#xd;
 * @return a promise for an array of promises&#xd;
 */&#xd;
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");&#xd;
function allResolved(promises) {&#xd;
    return when(promises, function (promises) {&#xd;
        promises = array_map(promises, Q);&#xd;
        return when(all(array_map(promises, function (promise) {&#xd;
            return when(promise, noop, noop);&#xd;
        })), function () {&#xd;
            return promises;&#xd;
        });&#xd;
    });&#xd;
}&#xd;
&#xd;
Promise.prototype.allResolved = function () {&#xd;
    return allResolved(this);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * @see Promise#allSettled&#xd;
 */&#xd;
Q.allSettled = allSettled;&#xd;
function allSettled(promises) {&#xd;
    return Q(promises).allSettled();&#xd;
}&#xd;
&#xd;
/**&#xd;
 * Turns an array of promises into a promise for an array of their states (as&#xd;
 * returned by `inspect`) when they have all settled.&#xd;
 * @param {Array[Any*]} values an array (or promise for an array) of values (or&#xd;
 * promises for values)&#xd;
 * @returns {Array[State]} an array of states for the respective values.&#xd;
 */&#xd;
Promise.prototype.allSettled = function () {&#xd;
    return this.then(function (promises) {&#xd;
        return all(array_map(promises, function (promise) {&#xd;
            promise = Q(promise);&#xd;
            function regardless() {&#xd;
                return promise.inspect();&#xd;
            }&#xd;
            return promise.then(regardless, regardless);&#xd;
        }));&#xd;
    });&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Captures the failure of a promise, giving an oportunity to recover&#xd;
 * with a callback.  If the given promise is fulfilled, the returned&#xd;
 * promise is fulfilled.&#xd;
 * @param {Any*} promise for something&#xd;
 * @param {Function} callback to fulfill the returned promise if the&#xd;
 * given promise is rejected&#xd;
 * @returns a promise for the return value of the callback&#xd;
 */&#xd;
Q.fail = // XXX legacy&#xd;
Q["catch"] = function (object, rejected) {&#xd;
    return Q(object).then(void 0, rejected);&#xd;
};&#xd;
&#xd;
Promise.prototype.fail = // XXX legacy&#xd;
Promise.prototype["catch"] = function (rejected) {&#xd;
    return this.then(void 0, rejected);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Attaches a listener that can respond to progress notifications from a&#xd;
 * promise's originating deferred. This listener receives the exact arguments&#xd;
 * passed to ``deferred.notify``.&#xd;
 * @param {Any*} promise for something&#xd;
 * @param {Function} callback to receive any progress notifications&#xd;
 * @returns the given promise, unchanged&#xd;
 */&#xd;
Q.progress = progress;&#xd;
function progress(object, progressed) {&#xd;
    return Q(object).then(void 0, void 0, progressed);&#xd;
}&#xd;
&#xd;
Promise.prototype.progress = function (progressed) {&#xd;
    return this.then(void 0, void 0, progressed);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Provides an opportunity to observe the settling of a promise,&#xd;
 * regardless of whether the promise is fulfilled or rejected.  Forwards&#xd;
 * the resolution to the returned promise when the callback is done.&#xd;
 * The callback can return a promise to defer completion.&#xd;
 * @param {Any*} promise&#xd;
 * @param {Function} callback to observe the resolution of the given&#xd;
 * promise, takes no arguments.&#xd;
 * @returns a promise for the resolution of the given promise when&#xd;
 * ``fin`` is done.&#xd;
 */&#xd;
Q.fin = // XXX legacy&#xd;
Q["finally"] = function (object, callback) {&#xd;
    return Q(object)["finally"](callback);&#xd;
};&#xd;
&#xd;
Promise.prototype.fin = // XXX legacy&#xd;
Promise.prototype["finally"] = function (callback) {&#xd;
    callback = Q(callback);&#xd;
    return this.then(function (value) {&#xd;
        return callback.fcall().then(function () {&#xd;
            return value;&#xd;
        });&#xd;
    }, function (reason) {&#xd;
        // TODO attempt to recycle the rejection with "this".&#xd;
        return callback.fcall().then(function () {&#xd;
            throw reason;&#xd;
        });&#xd;
    });&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Terminates a chain of promises, forcing rejections to be&#xd;
 * thrown as exceptions.&#xd;
 * @param {Any*} promise at the end of a chain of promises&#xd;
 * @returns nothing&#xd;
 */&#xd;
Q.done = function (object, fulfilled, rejected, progress) {&#xd;
    return Q(object).done(fulfilled, rejected, progress);&#xd;
};&#xd;
&#xd;
Promise.prototype.done = function (fulfilled, rejected, progress) {&#xd;
    var onUnhandledError = function (error) {&#xd;
        // forward to a future turn so that ``when``&#xd;
        // does not catch it and turn it into a rejection.&#xd;
        Q.nextTick(function () {&#xd;
            makeStackTraceLong(error, promise);&#xd;
            if (Q.onerror) {&#xd;
                Q.onerror(error);&#xd;
            } else {&#xd;
                throw error;&#xd;
            }&#xd;
        });&#xd;
    };&#xd;
&#xd;
    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.&#xd;
    var promise = fulfilled || rejected || progress ?&#xd;
        this.then(fulfilled, rejected, progress) :&#xd;
        this;&#xd;
&#xd;
    if (typeof process === "object" &amp;&amp; process &amp;&amp; process.domain) {&#xd;
        onUnhandledError = process.domain.bind(onUnhandledError);&#xd;
    }&#xd;
&#xd;
    promise.then(void 0, onUnhandledError);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Causes a promise to be rejected if it does not get fulfilled before&#xd;
 * some milliseconds time out.&#xd;
 * @param {Any*} promise&#xd;
 * @param {Number} milliseconds timeout&#xd;
 * @param {Any*} custom error message or Error object (optional)&#xd;
 * @returns a promise for the resolution of the given promise if it is&#xd;
 * fulfilled before the timeout, otherwise rejected.&#xd;
 */&#xd;
Q.timeout = function (object, ms, error) {&#xd;
    return Q(object).timeout(ms, error);&#xd;
};&#xd;
&#xd;
Promise.prototype.timeout = function (ms, error) {&#xd;
    var deferred = defer();&#xd;
    var timeoutId = setTimeout(function () {&#xd;
        if (!error || "string" === typeof error) {&#xd;
            error = new Error(error || "Timed out after " + ms + " ms");&#xd;
            error.code = "ETIMEDOUT";&#xd;
        }&#xd;
        deferred.reject(error);&#xd;
    }, ms);&#xd;
&#xd;
    this.then(function (value) {&#xd;
        clearTimeout(timeoutId);&#xd;
        deferred.resolve(value);&#xd;
    }, function (exception) {&#xd;
        clearTimeout(timeoutId);&#xd;
        deferred.reject(exception);&#xd;
    }, deferred.notify);&#xd;
&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Returns a promise for the given value (or promised value), some&#xd;
 * milliseconds after it resolved. Passes rejections immediately.&#xd;
 * @param {Any*} promise&#xd;
 * @param {Number} milliseconds&#xd;
 * @returns a promise for the resolution of the given promise after milliseconds&#xd;
 * time has elapsed since the resolution of the given promise.&#xd;
 * If the given promise rejects, that is passed immediately.&#xd;
 */&#xd;
Q.delay = function (object, timeout) {&#xd;
    if (timeout === void 0) {&#xd;
        timeout = object;&#xd;
        object = void 0;&#xd;
    }&#xd;
    return Q(object).delay(timeout);&#xd;
};&#xd;
&#xd;
Promise.prototype.delay = function (timeout) {&#xd;
    return this.then(function (value) {&#xd;
        var deferred = defer();&#xd;
        setTimeout(function () {&#xd;
            deferred.resolve(value);&#xd;
        }, timeout);&#xd;
        return deferred.promise;&#xd;
    });&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Passes a continuation to a Node function, which is called with the given&#xd;
 * arguments provided as an array, and returns a promise.&#xd;
 *&#xd;
 *      Q.nfapply(FS.readFile, [__filename])&#xd;
 *      .then(function (content) {&#xd;
 *      })&#xd;
 *&#xd;
 */&#xd;
Q.nfapply = function (callback, args) {&#xd;
    return Q(callback).nfapply(args);&#xd;
};&#xd;
&#xd;
Promise.prototype.nfapply = function (args) {&#xd;
    var deferred = defer();&#xd;
    var nodeArgs = array_slice(args);&#xd;
    nodeArgs.push(deferred.makeNodeResolver());&#xd;
    this.fapply(nodeArgs).fail(deferred.reject);&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Passes a continuation to a Node function, which is called with the given&#xd;
 * arguments provided individually, and returns a promise.&#xd;
 * @example&#xd;
 * Q.nfcall(FS.readFile, __filename)&#xd;
 * .then(function (content) {&#xd;
 * })&#xd;
 *&#xd;
 */&#xd;
Q.nfcall = function (callback /*...args*/) {&#xd;
    var args = array_slice(arguments, 1);&#xd;
    return Q(callback).nfapply(args);&#xd;
};&#xd;
&#xd;
Promise.prototype.nfcall = function (/*...args*/) {&#xd;
    var nodeArgs = array_slice(arguments);&#xd;
    var deferred = defer();&#xd;
    nodeArgs.push(deferred.makeNodeResolver());&#xd;
    this.fapply(nodeArgs).fail(deferred.reject);&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Wraps a NodeJS continuation passing function and returns an equivalent&#xd;
 * version that returns a promise.&#xd;
 * @example&#xd;
 * Q.nfbind(FS.readFile, __filename)("utf-8")&#xd;
 * .then(console.log)&#xd;
 * .done()&#xd;
 */&#xd;
Q.nfbind =&#xd;
Q.denodeify = function (callback /*...args*/) {&#xd;
    var baseArgs = array_slice(arguments, 1);&#xd;
    return function () {&#xd;
        var nodeArgs = baseArgs.concat(array_slice(arguments));&#xd;
        var deferred = defer();&#xd;
        nodeArgs.push(deferred.makeNodeResolver());&#xd;
        Q(callback).fapply(nodeArgs).fail(deferred.reject);&#xd;
        return deferred.promise;&#xd;
    };&#xd;
};&#xd;
&#xd;
Promise.prototype.nfbind =&#xd;
Promise.prototype.denodeify = function (/*...args*/) {&#xd;
    var args = array_slice(arguments);&#xd;
    args.unshift(this);&#xd;
    return Q.denodeify.apply(void 0, args);&#xd;
};&#xd;
&#xd;
Q.nbind = function (callback, thisp /*...args*/) {&#xd;
    var baseArgs = array_slice(arguments, 2);&#xd;
    return function () {&#xd;
        var nodeArgs = baseArgs.concat(array_slice(arguments));&#xd;
        var deferred = defer();&#xd;
        nodeArgs.push(deferred.makeNodeResolver());&#xd;
        function bound() {&#xd;
            return callback.apply(thisp, arguments);&#xd;
        }&#xd;
        Q(bound).fapply(nodeArgs).fail(deferred.reject);&#xd;
        return deferred.promise;&#xd;
    };&#xd;
};&#xd;
&#xd;
Promise.prototype.nbind = function (/*thisp, ...args*/) {&#xd;
    var args = array_slice(arguments, 0);&#xd;
    args.unshift(this);&#xd;
    return Q.nbind.apply(void 0, args);&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Calls a method of a Node-style object that accepts a Node-style&#xd;
 * callback with a given array of arguments, plus a provided callback.&#xd;
 * @param object an object that has the named method&#xd;
 * @param {String} name name of the method of object&#xd;
 * @param {Array} args arguments to pass to the method; the callback&#xd;
 * will be provided by Q and appended to these arguments.&#xd;
 * @returns a promise for the value or error&#xd;
 */&#xd;
Q.nmapply = // XXX As proposed by "Redsandro"&#xd;
Q.npost = function (object, name, args) {&#xd;
    return Q(object).npost(name, args);&#xd;
};&#xd;
&#xd;
Promise.prototype.nmapply = // XXX As proposed by "Redsandro"&#xd;
Promise.prototype.npost = function (name, args) {&#xd;
    var nodeArgs = array_slice(args || []);&#xd;
    var deferred = defer();&#xd;
    nodeArgs.push(deferred.makeNodeResolver());&#xd;
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * Calls a method of a Node-style object that accepts a Node-style&#xd;
 * callback, forwarding the given variadic arguments, plus a provided&#xd;
 * callback argument.&#xd;
 * @param object an object that has the named method&#xd;
 * @param {String} name name of the method of object&#xd;
 * @param ...args arguments to pass to the method; the callback will&#xd;
 * be provided by Q and appended to these arguments.&#xd;
 * @returns a promise for the value or error&#xd;
 */&#xd;
Q.nsend = // XXX Based on Mark Miller's proposed "send"&#xd;
Q.nmcall = // XXX Based on "Redsandro's" proposal&#xd;
Q.ninvoke = function (object, name /*...args*/) {&#xd;
    var nodeArgs = array_slice(arguments, 2);&#xd;
    var deferred = defer();&#xd;
    nodeArgs.push(deferred.makeNodeResolver());&#xd;
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"&#xd;
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal&#xd;
Promise.prototype.ninvoke = function (name /*...args*/) {&#xd;
    var nodeArgs = array_slice(arguments, 1);&#xd;
    var deferred = defer();&#xd;
    nodeArgs.push(deferred.makeNodeResolver());&#xd;
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);&#xd;
    return deferred.promise;&#xd;
};&#xd;
&#xd;
/**&#xd;
 * If a function would like to support both Node continuation-passing-style and&#xd;
 * promise-returning-style, it can end its internal promise chain with&#xd;
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user&#xd;
 * elects to use a nodeback, the result will be sent there.  If they do not&#xd;
 * pass a nodeback, they will receive the result promise.&#xd;
 * @param object a result (or a promise for a result)&#xd;
 * @param {Function} nodeback a Node.js-style callback&#xd;
 * @returns either the promise or nothing&#xd;
 */&#xd;
Q.nodeify = nodeify;&#xd;
function nodeify(object, nodeback) {&#xd;
    return Q(object).nodeify(nodeback);&#xd;
}&#xd;
&#xd;
Promise.prototype.nodeify = function (nodeback) {&#xd;
    if (nodeback) {&#xd;
        this.then(function (value) {&#xd;
            Q.nextTick(function () {&#xd;
                nodeback(null, value);&#xd;
            });&#xd;
        }, function (error) {&#xd;
            Q.nextTick(function () {&#xd;
                nodeback(error);&#xd;
            });&#xd;
        });&#xd;
    } else {&#xd;
        return this;&#xd;
    }&#xd;
};&#xd;
&#xd;
// All code before this point will be filtered from stack traces.&#xd;
var qEndingLine = captureLine();&#xd;
&#xd;
return Q;&#xd;
&#xd;
});&#xd;
&#xd;
}).call(this,require("/Users/antoine/projects/oauth-js/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))&#xd;
},{"/Users/antoine/projects/oauth-js/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":15}]},{},[8])&#xd;
});</code>
    </property>
    <property>
      <name>oauth-js</name>
    </property>
    <property>
      <parse>0</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>RISCOSSPlatformCode.GithubLogin</name>
    <number>2</number>
    <className>XWiki.JavaScriptExtension</className>
    <guid>50a09b7c-7d1a-46c2-9923-adbde68044dd</guid>
    <class>
      <name>XWiki.JavaScriptExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <disabled>0</disabled>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage=Always on this page|onDemand=On demand|always=Always on this wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>forbid</cache>
    </property>
    <property>
      <code>require(['jquery'],function($){&#xd;
$(function(){&#xd;
&#xd;
## Get RISCOSS platform configuration information&#xd;
#set($confDoc = $xwiki.getDocument("RISCOSSPlatformCode.RISCOSSConfiguration"))&#xd;
#set($confObj = $confDoc.getObject("RISCOSSPlatformCode.RISCOSSConfiguration"))&#xd;
#set($oauthPublicKey = $confObj.getProperty("oauthPublicKey").getValue())&#xd;
#if("$!oauthPublicKey" != "")&#xd;
//Initialize connect github button&#xd;
$('#connectGithub').click(function(event){&#xd;
event.preventDefault();&#xd;
//PopUp mode&#xd;
//Initialize the public key (got from https://oauth.io/)&#xd;
OAuth.initialize("$oauthPublicKey");&#xd;
var provider = 'github';&#xd;
OAuth.popup(provider)&#xd;
.done(function(result) {&#xd;
     //After getting the authorization send a request to github to get information about the connected user&#xd;
     result.me()&#xd;
    .done(function (response) {&#xd;
        //Create the XWiki user if not exists&#xd;
        var saveURL = "$xwiki.getURL('RISCOSSPlatformCode.GithubLogin','view','xpage=plain&amp;outputSyntax=plain')";&#xd;
        var data = response;&#xd;
        var fullName = response.name;&#xd;
        var firstName = "";&#xd;
        var lastName = "";&#xd;
        firstName = (fullName &amp;&amp; fullName != "") ? fullName.split(" ")[0] : fullName;&#xd;
        lastName = (fullName &amp;&amp; fullName != "" &amp;&amp; fullName.split(" ").length == 2) ? fullName.split(" ")[1] : fullName;&#xd;
        var password = Math.random().toString(36).slice(-8);&#xd;
        //Set xwiki register form parameters&#xd;
        data.register_first_name = firstName;&#xd;
        data.register_last_name = lastName;&#xd;
        data.xwikiname = "github_" + response.alias;&#xd;
        data.register_password = password;&#xd;
        data.register2_password = password;&#xd;
        data.register_email = response.email;&#xd;
        var request = $.ajax({&#xd;
          url: saveURL,&#xd;
             method: "POST",&#xd;
             data: response,&#xd;
             dataType: "json"&#xd;
          });&#xd;
          request.done(function( msg ) {&#xd;
             if(msg.rep &amp;&amp; msg.rep == 1){//Success&#xd;
               if(msg.loginURL){&#xd;
                  //Authentificate&#xd;
                  document.location.replace(msg.loginURL); &#xd;
               }&#xd;
             }&#xd;
             else&#xd;
             {&#xd;
                //Go to the main page&#xd;
                document.location.replace("$xwiki.getURL('Main.WebHome')"); &#xd;
             }&#xd;
          });&#xd;
          request.fail(function( jqXHR, textStatus ) {&#xd;
            alert( "Request failed: " + textStatus );&#xd;
          });&#xd;
    })&#xd;
    .fail(function (err) {&#xd;
        //handle error with err&#xd;
    });&#xd;
})&#xd;
.fail(function (err) {&#xd;
    //handle error with err&#xd;
});&#xd;
});&#xd;
#end&#xd;
});&#xd;
});</code>
    </property>
    <property>
      <name>Initialize OAuth</name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
  <object>
    <name>RISCOSSPlatformCode.GithubLogin</name>
    <number>3</number>
    <className>XWiki.StyleSheetExtension</className>
    <guid>b97efb1b-b176-431b-89ce-d01b1a37d11d</guid>
    <class>
      <name>XWiki.StyleSheetExtension</name>
      <customClass/>
      <customMapping/>
      <defaultViewSheet/>
      <defaultEditSheet/>
      <defaultWeb/>
      <nameField/>
      <validationScript/>
      <cache>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>cache</name>
        <number>5</number>
        <prettyName>Caching policy</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>long|short|default|forbid</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </cache>
      <code>
        <disabled>0</disabled>
        <name>code</name>
        <number>2</number>
        <prettyName>Code</prettyName>
        <rows>20</rows>
        <size>50</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.TextAreaClass</classType>
      </code>
      <name>
        <disabled>0</disabled>
        <name>name</name>
        <number>1</number>
        <prettyName>Name</prettyName>
        <size>30</size>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.StringClass</classType>
      </name>
      <parse>
        <disabled>0</disabled>
        <displayFormType>select</displayFormType>
        <displayType>yesno</displayType>
        <name>parse</name>
        <number>4</number>
        <prettyName>Parse content</prettyName>
        <unmodifiable>0</unmodifiable>
        <classType>com.xpn.xwiki.objects.classes.BooleanClass</classType>
      </parse>
      <use>
        <cache>0</cache>
        <disabled>0</disabled>
        <displayType>select</displayType>
        <multiSelect>0</multiSelect>
        <name>use</name>
        <number>3</number>
        <prettyName>Use this extension</prettyName>
        <relationalStorage>0</relationalStorage>
        <separator> </separator>
        <separators> ,|</separators>
        <size>1</size>
        <unmodifiable>0</unmodifiable>
        <values>currentPage=Always on this page|onDemand=On demand|always=Always on this wiki</values>
        <classType>com.xpn.xwiki.objects.classes.StaticListClass</classType>
      </use>
    </class>
    <property>
      <cache>long</cache>
    </property>
    <property>
      <code>#connectGithub{&#xd;
    background-image: url("$doc.getAttachmentURL('github.png')");&#xd;
    background-position: left center;&#xd;
    background-repeat: no-repeat;&#xd;
    display: inline-block;&#xd;
    height: 20px;&#xd;
    padding-left: 22px;&#xd;
    padding-top: 3px;&#xd;
    font-size: larger;&#xd;
    color: #ffffff;&#xd;
}&#xd;
#loginlink, #registerlink, .guestmenuitem{&#xd;
   font-size: larger;&#xd;
   color: #ffffff !important;&#xd;
}</code>
    </property>
    <property>
      <name></name>
    </property>
    <property>
      <parse>1</parse>
    </property>
    <property>
      <use>onDemand</use>
    </property>
  </object>
</xwikidoc>